"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_data_philosopher-loader_ts"],{

/***/ "(app-pages-browser)/./lib/data/philosopher-loader.ts":
/*!****************************************!*\
  !*** ./lib/data/philosopher-loader.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateConnections: function() { return /* binding */ generateConnections; },\n/* harmony export */   loadPhilosopherData: function() { return /* binding */ loadPhilosopherData; },\n/* harmony export */   transformPhilosopherData: function() { return /* binding */ transformPhilosopherData; }\n/* harmony export */ });\n/**\n * Generates 3D position based on philosopher's characteristics\n */ function calculatePosition(philosopher, index, total) {\n    // Use era and primary characteristics to position in 3D space\n    const eraRadius = philosopher.eraPosition * 8; // Scale era position to radius\n    // Map era to angle ranges\n    const eraAngles = {\n        \"Ancient\": [\n            0,\n            Math.PI / 2\n        ],\n        \"Medieval\": [\n            Math.PI / 2,\n            Math.PI\n        ],\n        \"Modern\": [\n            Math.PI,\n            3 * Math.PI / 2\n        ],\n        \"Contemporary\": [\n            3 * Math.PI / 2,\n            2 * Math.PI\n        ]\n    };\n    const [minAngle, maxAngle] = eraAngles[philosopher.era] || [\n        0,\n        2 * Math.PI\n    ];\n    const angle = minAngle + philosopher.eraPosition * (maxAngle - minAngle);\n    // Use genome characteristics for height positioning\n    const genomeHeight = getGenomeHeight(philosopher.philosophicalGenome);\n    // Add some randomness based on philosopher's unique characteristics\n    const uniqueOffset = philosopher.name.charCodeAt(0) % 100 / 100;\n    const x = eraRadius * Math.cos(angle) + uniqueOffset;\n    const z = eraRadius * Math.sin(angle) + uniqueOffset;\n    const y = genomeHeight * 4 - 2; // Range from -2 to 2\n    return [\n        x,\n        y,\n        z\n    ];\n}\n/**\n * Calculate height based on philosophical genome characteristics\n */ function getGenomeHeight(genome) {\n    // Map genome positions to numerical values for height calculation\n    const values = [\n        getGenomeValue(genome.beingVsBecoming),\n        getGenomeValue(genome.oneVsMany),\n        getGenomeValue(genome.mindVsMatter),\n        getGenomeValue(genome.freedomVsDeterminism),\n        getGenomeValue(genome.transcendentVsImmanent),\n        getGenomeValue(genome.realismVsAntiRealism),\n        getGenomeValue(genome.reasonVsExperience),\n        getGenomeValue(genome.absoluteVsRelative)\n    ];\n    return values.reduce((sum, val)=>sum + val, 0) / values.length;\n}\nfunction getGenomeValue(position) {\n    const valueMap = {\n        \"Being\": 0.2,\n        \"Becoming\": 0.8,\n        \"One\": 0.2,\n        \"Many\": 0.8,\n        \"Mind\": 0.2,\n        \"Matter\": 0.8,\n        \"Freedom\": 0.8,\n        \"Determinism\": 0.2,\n        \"Transcendent\": 0.8,\n        \"Immanent\": 0.2,\n        \"Realist\": 0.2,\n        \"Anti-realist\": 0.8,\n        \"Reason\": 0.2,\n        \"Experience\": 0.8,\n        \"Absolute\": 0.2,\n        \"Relative\": 0.8,\n        \"Both\": 0.5,\n        \"Dualist\": 0.5,\n        \"Synthesis\": 0.5\n    };\n    return valueMap[position] || 0.5;\n}\n/**\n * Transform raw philosopher data into PhilosopherNode format\n */ function transformPhilosopherData(rawData) {\n    return rawData.map((raw, index)=>({\n            id: raw.id,\n            name: raw.name,\n            birthYear: raw.birthYear,\n            deathYear: raw.deathYear,\n            position: calculatePosition(raw, index, rawData.length),\n            spiralDynamicsStage: raw.spiralDynamicsStage,\n            spiralJustification: raw.spiralJustification,\n            philosophicalGenome: {\n                beingVsBecoming: raw.philosophicalGenome.beingVsBecoming,\n                oneVsMany: raw.philosophicalGenome.oneVsMany,\n                mindVsMatter: raw.philosophicalGenome.mindVsMatter,\n                freedomVsDeterminism: raw.philosophicalGenome.freedomVsDeterminism,\n                transcendentVsImmanent: raw.philosophicalGenome.transcendentVsImmanent,\n                realismVsAntiRealism: raw.philosophicalGenome.realismVsAntiRealism,\n                reasonVsExperience: raw.philosophicalGenome.reasonVsExperience,\n                absoluteVsRelative: raw.philosophicalGenome.absoluteVsRelative\n            },\n            switchPoints: raw.switchPoints || [],\n            domainStrengths: raw.domainStrengths,\n            influences: raw.influences || [],\n            critiques: raw.critiques || [],\n            comprehensiveBiography: raw.comprehensiveBiography,\n            intellectualJourney: raw.intellectualJourney,\n            primaryDomain: raw.primaryDomain,\n            era: raw.era,\n            eraPosition: raw.eraPosition,\n            birthLocation: raw.birthLocation,\n            allDomains: raw.allDomains,\n            historicalContext: raw.historicalContext,\n            spiralTransitions: raw.spiralTransitions\n        }));\n}\n/**\n * Generate connections based on influence and critique relationships\n */ function generateConnections(rawData) {\n    const connections = [];\n    rawData.forEach((philosopher)=>{\n        // Process influences\n        if (philosopher.influenceMap) {\n            Object.entries(philosopher.influenceMap).forEach((param)=>{\n                let [sourceId, strength] = param;\n                connections.push({\n                    sourceId,\n                    targetId: philosopher.id,\n                    strength,\n                    type: \"influence\",\n                    description: \"Influences \".concat(philosopher.name, \"'s philosophical development\")\n                });\n            });\n        }\n        // Process critiques\n        if (philosopher.critiqueMap) {\n            Object.entries(philosopher.critiqueMap).forEach((param)=>{\n                let [targetId, strength] = param;\n                connections.push({\n                    sourceId: philosopher.id,\n                    targetId,\n                    strength,\n                    type: \"critique\",\n                    description: \"\".concat(philosopher.name, \" critiques this philosophical position\")\n                });\n            });\n        }\n    });\n    return connections;\n}\n/**\n * Load and process philosopher data from database API\n */ async function loadPhilosopherData() {\n    try {\n        const response = await fetch(\"/api/philosophers\");\n        if (!response.ok) {\n            throw new Error(\"Failed to load philosopher data: \".concat(response.statusText));\n        }\n        const rawData = await response.json();\n        const philosophers = transformPhilosopherData(rawData);\n        const connections = generateConnections(rawData);\n        console.log(\"Loaded \".concat(philosophers.length, \" philosophers and \").concat(connections.length, \" connections\"));\n        return {\n            philosophers,\n            connections\n        };\n    } catch (error) {\n        console.error(\"Error loading philosopher data:\", error);\n        // Fallback to JSON file if API fails\n        try {\n            const fallbackResponse = await fetch(\"/data/philosophers.json\");\n            if (fallbackResponse.ok) {\n                const fallbackData = await fallbackResponse.json();\n                const philosophers = transformPhilosopherData(fallbackData);\n                const connections = generateConnections(fallbackData);\n                console.log(\"Using fallback JSON data:\", philosophers.length, \"philosophers\");\n                return {\n                    philosophers,\n                    connections\n                };\n            }\n        } catch (fallbackError) {\n            console.error(\"Fallback also failed:\", fallbackError);\n        }\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhL3BoaWxvc29waGVyLWxvYWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUErQ0E7O0NBRUMsR0FDRCxTQUFTQSxrQkFBa0JDLFdBQStCLEVBQUVDLEtBQWEsRUFBRUMsS0FBYTtJQUN0Riw4REFBOEQ7SUFDOUQsTUFBTUMsWUFBWUgsWUFBWUksV0FBVyxHQUFHLEdBQUcsK0JBQStCO0lBRTlFLDBCQUEwQjtJQUMxQixNQUFNQyxZQUE4QztRQUNsRCxXQUFXO1lBQUM7WUFBR0MsS0FBS0MsRUFBRSxHQUFHO1NBQUU7UUFDM0IsWUFBWTtZQUFDRCxLQUFLQyxFQUFFLEdBQUc7WUFBR0QsS0FBS0MsRUFBRTtTQUFDO1FBQ2xDLFVBQVU7WUFBQ0QsS0FBS0MsRUFBRTtZQUFFLElBQUlELEtBQUtDLEVBQUUsR0FBRztTQUFFO1FBQ3BDLGdCQUFnQjtZQUFDLElBQUlELEtBQUtDLEVBQUUsR0FBRztZQUFHLElBQUlELEtBQUtDLEVBQUU7U0FBQztJQUNoRDtJQUVBLE1BQU0sQ0FBQ0MsVUFBVUMsU0FBUyxHQUFHSixTQUFTLENBQUNMLFlBQVlVLEdBQUcsQ0FBQyxJQUFJO1FBQUM7UUFBRyxJQUFJSixLQUFLQyxFQUFFO0tBQUM7SUFDM0UsTUFBTUksUUFBUUgsV0FBWVIsWUFBWUksV0FBVyxHQUFJSyxDQUFBQSxXQUFXRCxRQUFPO0lBRXZFLG9EQUFvRDtJQUNwRCxNQUFNSSxlQUFlQyxnQkFBZ0JiLFlBQVljLG1CQUFtQjtJQUVwRSxvRUFBb0U7SUFDcEUsTUFBTUMsZUFBZSxZQUFhQyxJQUFJLENBQUNDLFVBQVUsQ0FBQyxLQUFLLE1BQU87SUFFOUQsTUFBTUMsSUFBSWYsWUFBWUcsS0FBS2EsR0FBRyxDQUFDUixTQUFTSTtJQUN4QyxNQUFNSyxJQUFJakIsWUFBWUcsS0FBS2UsR0FBRyxDQUFDVixTQUFTSTtJQUN4QyxNQUFNTyxJQUFJVixlQUFlLElBQUksR0FBRyxxQkFBcUI7SUFFckQsT0FBTztRQUFDTTtR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SyxDQUFDLG1DQUFtQ0E7UUFDakQscUNBQXFDO1FBQ3JDLElBQUk7WUFDRixNQUFNQyxtQkFBbUIsTUFBTVQsTUFBTTtZQUNyQyxJQUFJUyxpQkFBaUJSLEVBQUUsRUFBRTtnQkFDdkIsTUFBTVMsZUFBcUMsTUFBTUQsaUJBQWlCTCxJQUFJO2dCQUN0RSxNQUFNQyxlQUFleEMseUJBQXlCNkM7Z0JBQzlDLE1BQU14QixjQUFjRCxvQkFBb0J5QjtnQkFDeENKLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJGLGFBQWEzQyxNQUFNLEVBQUU7Z0JBQzlELE9BQU87b0JBQUUyQztvQkFBY25CO2dCQUFZO1lBQ3JDO1FBQ0YsRUFBRSxPQUFPeUIsZUFBZTtZQUN0QkwsUUFBUUUsS0FBSyxDQUFDLHlCQUF5Qkc7UUFDekM7UUFDQSxNQUFNSDtJQUNSO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2RhdGEvcGhpbG9zb3BoZXItbG9hZGVyLnRzPzkzZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGhpbG9zb3BoZXJOb2RlLCBDb25uZWN0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhd1BoaWxvc29waGVyRGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgYmlydGhZZWFyOiBudW1iZXI7XG4gIGRlYXRoWWVhcjogbnVtYmVyO1xuICBiaXJ0aExvY2F0aW9uPzoge1xuICAgIGNpdHk6IHN0cmluZztcbiAgICByZWdpb246IHN0cmluZztcbiAgICBtb2Rlcm5Db3VudHJ5OiBzdHJpbmc7XG4gICAgY29vcmRpbmF0ZXM6IFtudW1iZXIsIG51bWJlcl07XG4gIH07XG4gIHByaW1hcnlEb21haW46IHN0cmluZztcbiAgYWxsRG9tYWlucz86IHN0cmluZ1tdO1xuICBkb21haW5TdHJlbmd0aHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGVyYTogc3RyaW5nO1xuICBlcmFQb3NpdGlvbjogbnVtYmVyO1xuICBzcGlyYWxEeW5hbWljc1N0YWdlOiBzdHJpbmc7XG4gIHNwaXJhbEp1c3RpZmljYXRpb246IHN0cmluZztcbiAgc3BpcmFsVHJhbnNpdGlvbnM/OiBzdHJpbmdbXTtcbiAgcGhpbG9zb3BoaWNhbEdlbm9tZToge1xuICAgIGJlaW5nVnNCZWNvbWluZzogc3RyaW5nO1xuICAgIG9uZVZzTWFueTogc3RyaW5nO1xuICAgIG1pbmRWc01hdHRlcjogc3RyaW5nO1xuICAgIGZyZWVkb21Wc0RldGVybWluaXNtOiBzdHJpbmc7XG4gICAgdHJhbnNjZW5kZW50VnNJbW1hbmVudDogc3RyaW5nO1xuICAgIHJlYWxpc21Wc0FudGlSZWFsaXNtOiBzdHJpbmc7XG4gICAgcmVhc29uVnNFeHBlcmllbmNlOiBzdHJpbmc7XG4gICAgYWJzb2x1dGVWc1JlbGF0aXZlOiBzdHJpbmc7XG4gICAgZ2Vub21lSnVzdGlmaWNhdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB9O1xuICBzd2l0Y2hQb2ludHM/OiBBcnJheTx7XG4gICAgcXVlc3Rpb246IHN0cmluZztcbiAgICBwb3NpdGlvbjogc3RyaW5nO1xuICAgIGFyZ3VtZW50OiBzdHJpbmc7XG4gICAgZG9tYWluQ2FzY2FkZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB9PjtcbiAgY29tcHJlaGVuc2l2ZUJpb2dyYXBoeTogc3RyaW5nO1xuICBpbnRlbGxlY3R1YWxKb3VybmV5OiBzdHJpbmc7XG4gIGhpc3RvcmljYWxDb250ZXh0Pzogc3RyaW5nO1xuICBpbmZsdWVuY2VzPzogc3RyaW5nW107XG4gIGNyaXRpcXVlcz86IHN0cmluZ1tdO1xuICBpbmZsdWVuY2VNYXA/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICBjcml0aXF1ZU1hcD86IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIDNEIHBvc2l0aW9uIGJhc2VkIG9uIHBoaWxvc29waGVyJ3MgY2hhcmFjdGVyaXN0aWNzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uKHBoaWxvc29waGVyOiBSYXdQaGlsb3NvcGhlckRhdGEsIGluZGV4OiBudW1iZXIsIHRvdGFsOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAvLyBVc2UgZXJhIGFuZCBwcmltYXJ5IGNoYXJhY3RlcmlzdGljcyB0byBwb3NpdGlvbiBpbiAzRCBzcGFjZVxuICBjb25zdCBlcmFSYWRpdXMgPSBwaGlsb3NvcGhlci5lcmFQb3NpdGlvbiAqIDg7IC8vIFNjYWxlIGVyYSBwb3NpdGlvbiB0byByYWRpdXNcbiAgXG4gIC8vIE1hcCBlcmEgdG8gYW5nbGUgcmFuZ2VzXG4gIGNvbnN0IGVyYUFuZ2xlczogUmVjb3JkPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4gPSB7XG4gICAgJ0FuY2llbnQnOiBbMCwgTWF0aC5QSSAvIDJdLFxuICAgICdNZWRpZXZhbCc6IFtNYXRoLlBJIC8gMiwgTWF0aC5QSV0sXG4gICAgJ01vZGVybic6IFtNYXRoLlBJLCAzICogTWF0aC5QSSAvIDJdLFxuICAgICdDb250ZW1wb3JhcnknOiBbMyAqIE1hdGguUEkgLyAyLCAyICogTWF0aC5QSV1cbiAgfTtcbiAgXG4gIGNvbnN0IFttaW5BbmdsZSwgbWF4QW5nbGVdID0gZXJhQW5nbGVzW3BoaWxvc29waGVyLmVyYV0gfHwgWzAsIDIgKiBNYXRoLlBJXTtcbiAgY29uc3QgYW5nbGUgPSBtaW5BbmdsZSArIChwaGlsb3NvcGhlci5lcmFQb3NpdGlvbiAqIChtYXhBbmdsZSAtIG1pbkFuZ2xlKSk7XG4gIFxuICAvLyBVc2UgZ2Vub21lIGNoYXJhY3RlcmlzdGljcyBmb3IgaGVpZ2h0IHBvc2l0aW9uaW5nXG4gIGNvbnN0IGdlbm9tZUhlaWdodCA9IGdldEdlbm9tZUhlaWdodChwaGlsb3NvcGhlci5waGlsb3NvcGhpY2FsR2Vub21lKTtcbiAgXG4gIC8vIEFkZCBzb21lIHJhbmRvbW5lc3MgYmFzZWQgb24gcGhpbG9zb3BoZXIncyB1bmlxdWUgY2hhcmFjdGVyaXN0aWNzXG4gIGNvbnN0IHVuaXF1ZU9mZnNldCA9IChwaGlsb3NvcGhlci5uYW1lLmNoYXJDb2RlQXQoMCkgJSAxMDApIC8gMTAwO1xuICBcbiAgY29uc3QgeCA9IGVyYVJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSArIHVuaXF1ZU9mZnNldDtcbiAgY29uc3QgeiA9IGVyYVJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSArIHVuaXF1ZU9mZnNldDtcbiAgY29uc3QgeSA9IGdlbm9tZUhlaWdodCAqIDQgLSAyOyAvLyBSYW5nZSBmcm9tIC0yIHRvIDJcbiAgXG4gIHJldHVybiBbeCwgeSwgel07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGhlaWdodCBiYXNlZCBvbiBwaGlsb3NvcGhpY2FsIGdlbm9tZSBjaGFyYWN0ZXJpc3RpY3NcbiAqL1xuZnVuY3Rpb24gZ2V0R2Vub21lSGVpZ2h0KGdlbm9tZTogUmF3UGhpbG9zb3BoZXJEYXRhWydwaGlsb3NvcGhpY2FsR2Vub21lJ10pOiBudW1iZXIge1xuICAvLyBNYXAgZ2Vub21lIHBvc2l0aW9ucyB0byBudW1lcmljYWwgdmFsdWVzIGZvciBoZWlnaHQgY2FsY3VsYXRpb25cbiAgY29uc3QgdmFsdWVzID0gW1xuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5iZWluZ1ZzQmVjb21pbmcpLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5vbmVWc01hbnkpLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5taW5kVnNNYXR0ZXIpLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5mcmVlZG9tVnNEZXRlcm1pbmlzbSksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLnRyYW5zY2VuZGVudFZzSW1tYW5lbnQpLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5yZWFsaXNtVnNBbnRpUmVhbGlzbSksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLnJlYXNvblZzRXhwZXJpZW5jZSksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLmFic29sdXRlVnNSZWxhdGl2ZSlcbiAgXTtcbiAgXG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKSAvIHZhbHVlcy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldEdlbm9tZVZhbHVlKHBvc2l0aW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCB2YWx1ZU1hcDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAnQmVpbmcnOiAwLjIsXG4gICAgJ0JlY29taW5nJzogMC44LFxuICAgICdPbmUnOiAwLjIsXG4gICAgJ01hbnknOiAwLjgsXG4gICAgJ01pbmQnOiAwLjIsXG4gICAgJ01hdHRlcic6IDAuOCxcbiAgICAnRnJlZWRvbSc6IDAuOCxcbiAgICAnRGV0ZXJtaW5pc20nOiAwLjIsXG4gICAgJ1RyYW5zY2VuZGVudCc6IDAuOCxcbiAgICAnSW1tYW5lbnQnOiAwLjIsXG4gICAgJ1JlYWxpc3QnOiAwLjIsXG4gICAgJ0FudGktcmVhbGlzdCc6IDAuOCxcbiAgICAnUmVhc29uJzogMC4yLFxuICAgICdFeHBlcmllbmNlJzogMC44LFxuICAgICdBYnNvbHV0ZSc6IDAuMixcbiAgICAnUmVsYXRpdmUnOiAwLjgsXG4gICAgJ0JvdGgnOiAwLjUsXG4gICAgJ0R1YWxpc3QnOiAwLjUsXG4gICAgJ1N5bnRoZXNpcyc6IDAuNVxuICB9O1xuICBcbiAgcmV0dXJuIHZhbHVlTWFwW3Bvc2l0aW9uXSB8fCAwLjU7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHJhdyBwaGlsb3NvcGhlciBkYXRhIGludG8gUGhpbG9zb3BoZXJOb2RlIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUGhpbG9zb3BoZXJEYXRhKHJhd0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdKTogUGhpbG9zb3BoZXJOb2RlW10ge1xuICByZXR1cm4gcmF3RGF0YS5tYXAoKHJhdywgaW5kZXgpID0+ICh7XG4gICAgaWQ6IHJhdy5pZCxcbiAgICBuYW1lOiByYXcubmFtZSxcbiAgICBiaXJ0aFllYXI6IHJhdy5iaXJ0aFllYXIsXG4gICAgZGVhdGhZZWFyOiByYXcuZGVhdGhZZWFyLFxuICAgIHBvc2l0aW9uOiBjYWxjdWxhdGVQb3NpdGlvbihyYXcsIGluZGV4LCByYXdEYXRhLmxlbmd0aCksXG4gICAgc3BpcmFsRHluYW1pY3NTdGFnZTogcmF3LnNwaXJhbER5bmFtaWNzU3RhZ2UsXG4gICAgc3BpcmFsSnVzdGlmaWNhdGlvbjogcmF3LnNwaXJhbEp1c3RpZmljYXRpb24sXG4gICAgcGhpbG9zb3BoaWNhbEdlbm9tZToge1xuICAgICAgYmVpbmdWc0JlY29taW5nOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5iZWluZ1ZzQmVjb21pbmcgYXMgYW55LFxuICAgICAgb25lVnNNYW55OiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5vbmVWc01hbnkgYXMgYW55LFxuICAgICAgbWluZFZzTWF0dGVyOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5taW5kVnNNYXR0ZXIgYXMgYW55LFxuICAgICAgZnJlZWRvbVZzRGV0ZXJtaW5pc206IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLmZyZWVkb21Wc0RldGVybWluaXNtIGFzIGFueSxcbiAgICAgIHRyYW5zY2VuZGVudFZzSW1tYW5lbnQ6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLnRyYW5zY2VuZGVudFZzSW1tYW5lbnQgYXMgYW55LFxuICAgICAgcmVhbGlzbVZzQW50aVJlYWxpc206IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLnJlYWxpc21Wc0FudGlSZWFsaXNtIGFzIGFueSxcbiAgICAgIHJlYXNvblZzRXhwZXJpZW5jZTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUucmVhc29uVnNFeHBlcmllbmNlIGFzIGFueSxcbiAgICAgIGFic29sdXRlVnNSZWxhdGl2ZTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUuYWJzb2x1dGVWc1JlbGF0aXZlIGFzIGFueSxcbiAgICB9LFxuICAgIHN3aXRjaFBvaW50czogcmF3LnN3aXRjaFBvaW50cyB8fCBbXSxcbiAgICBkb21haW5TdHJlbmd0aHM6IHJhdy5kb21haW5TdHJlbmd0aHMsXG4gICAgaW5mbHVlbmNlczogcmF3LmluZmx1ZW5jZXMgfHwgW10sXG4gICAgY3JpdGlxdWVzOiByYXcuY3JpdGlxdWVzIHx8IFtdLFxuICAgIGNvbXByZWhlbnNpdmVCaW9ncmFwaHk6IHJhdy5jb21wcmVoZW5zaXZlQmlvZ3JhcGh5LFxuICAgIGludGVsbGVjdHVhbEpvdXJuZXk6IHJhdy5pbnRlbGxlY3R1YWxKb3VybmV5LFxuICAgIHByaW1hcnlEb21haW46IHJhdy5wcmltYXJ5RG9tYWluLFxuICAgIGVyYTogcmF3LmVyYSBhcyBhbnksXG4gICAgZXJhUG9zaXRpb246IHJhdy5lcmFQb3NpdGlvbixcbiAgICBiaXJ0aExvY2F0aW9uOiByYXcuYmlydGhMb2NhdGlvbixcbiAgICBhbGxEb21haW5zOiByYXcuYWxsRG9tYWlucyxcbiAgICBoaXN0b3JpY2FsQ29udGV4dDogcmF3Lmhpc3RvcmljYWxDb250ZXh0LFxuICAgIHNwaXJhbFRyYW5zaXRpb25zOiByYXcuc3BpcmFsVHJhbnNpdGlvbnNcbiAgfSkpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbm5lY3Rpb25zIGJhc2VkIG9uIGluZmx1ZW5jZSBhbmQgY3JpdGlxdWUgcmVsYXRpb25zaGlwc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb25uZWN0aW9ucyhyYXdEYXRhOiBSYXdQaGlsb3NvcGhlckRhdGFbXSk6IENvbm5lY3Rpb25bXSB7XG4gIGNvbnN0IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10gPSBbXTtcbiAgXG4gIHJhd0RhdGEuZm9yRWFjaChwaGlsb3NvcGhlciA9PiB7XG4gICAgLy8gUHJvY2VzcyBpbmZsdWVuY2VzXG4gICAgaWYgKHBoaWxvc29waGVyLmluZmx1ZW5jZU1hcCkge1xuICAgICAgT2JqZWN0LmVudHJpZXMocGhpbG9zb3BoZXIuaW5mbHVlbmNlTWFwKS5mb3JFYWNoKChbc291cmNlSWQsIHN0cmVuZ3RoXSkgPT4ge1xuICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgICB0YXJnZXRJZDogcGhpbG9zb3BoZXIuaWQsXG4gICAgICAgICAgc3RyZW5ndGgsXG4gICAgICAgICAgdHlwZTogJ2luZmx1ZW5jZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBJbmZsdWVuY2VzICR7cGhpbG9zb3BoZXIubmFtZX0ncyBwaGlsb3NvcGhpY2FsIGRldmVsb3BtZW50YFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGNyaXRpcXVlc1xuICAgIGlmIChwaGlsb3NvcGhlci5jcml0aXF1ZU1hcCkge1xuICAgICAgT2JqZWN0LmVudHJpZXMocGhpbG9zb3BoZXIuY3JpdGlxdWVNYXApLmZvckVhY2goKFt0YXJnZXRJZCwgc3RyZW5ndGhdKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHNvdXJjZUlkOiBwaGlsb3NvcGhlci5pZCxcbiAgICAgICAgICB0YXJnZXRJZCxcbiAgICAgICAgICBzdHJlbmd0aCxcbiAgICAgICAgICB0eXBlOiAnY3JpdGlxdWUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtwaGlsb3NvcGhlci5uYW1lfSBjcml0aXF1ZXMgdGhpcyBwaGlsb3NvcGhpY2FsIHBvc2l0aW9uYFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIFxuICByZXR1cm4gY29ubmVjdGlvbnM7XG59XG5cbi8qKlxuICogTG9hZCBhbmQgcHJvY2VzcyBwaGlsb3NvcGhlciBkYXRhIGZyb20gZGF0YWJhc2UgQVBJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUGhpbG9zb3BoZXJEYXRhKCk6IFByb21pc2U8eyBwaGlsb3NvcGhlcnM6IFBoaWxvc29waGVyTm9kZVtdLCBjb25uZWN0aW9uczogQ29ubmVjdGlvbltdIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BoaWxvc29waGVycycpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgcGhpbG9zb3BoZXIgZGF0YTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByYXdEYXRhOiBSYXdQaGlsb3NvcGhlckRhdGFbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBjb25zdCBwaGlsb3NvcGhlcnMgPSB0cmFuc2Zvcm1QaGlsb3NvcGhlckRhdGEocmF3RGF0YSk7XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBnZW5lcmF0ZUNvbm5lY3Rpb25zKHJhd0RhdGEpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHtwaGlsb3NvcGhlcnMubGVuZ3RofSBwaGlsb3NvcGhlcnMgYW5kICR7Y29ubmVjdGlvbnMubGVuZ3RofSBjb25uZWN0aW9uc2ApO1xuICAgIFxuICAgIHJldHVybiB7IHBoaWxvc29waGVycywgY29ubmVjdGlvbnMgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHBoaWxvc29waGVyIGRhdGE6JywgZXJyb3IpO1xuICAgIC8vIEZhbGxiYWNrIHRvIEpTT04gZmlsZSBpZiBBUEkgZmFpbHNcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmFsbGJhY2tSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvZGF0YS9waGlsb3NvcGhlcnMuanNvbicpO1xuICAgICAgaWYgKGZhbGxiYWNrUmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tEYXRhOiBSYXdQaGlsb3NvcGhlckRhdGFbXSA9IGF3YWl0IGZhbGxiYWNrUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBwaGlsb3NvcGhlcnMgPSB0cmFuc2Zvcm1QaGlsb3NvcGhlckRhdGEoZmFsbGJhY2tEYXRhKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBnZW5lcmF0ZUNvbm5lY3Rpb25zKGZhbGxiYWNrRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBmYWxsYmFjayBKU09OIGRhdGE6JywgcGhpbG9zb3BoZXJzLmxlbmd0aCwgJ3BoaWxvc29waGVycycpO1xuICAgICAgICByZXR1cm4geyBwaGlsb3NvcGhlcnMsIGNvbm5lY3Rpb25zIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFsbGJhY2sgYWxzbyBmYWlsZWQ6JywgZmFsbGJhY2tFcnJvcik7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59Il0sIm5hbWVzIjpbImNhbGN1bGF0ZVBvc2l0aW9uIiwicGhpbG9zb3BoZXIiLCJpbmRleCIsInRvdGFsIiwiZXJhUmFkaXVzIiwiZXJhUG9zaXRpb24iLCJlcmFBbmdsZXMiLCJNYXRoIiwiUEkiLCJtaW5BbmdsZSIsIm1heEFuZ2xlIiwiZXJhIiwiYW5nbGUiLCJnZW5vbWVIZWlnaHQiLCJnZXRHZW5vbWVIZWlnaHQiLCJwaGlsb3NvcGhpY2FsR2Vub21lIiwidW5pcXVlT2Zmc2V0IiwibmFtZSIsImNoYXJDb2RlQXQiLCJ4IiwiY29zIiwieiIsInNpbiIsInkiLCJnZW5vbWUiLCJ2YWx1ZXMiLCJnZXRHZW5vbWVWYWx1ZSIsImJlaW5nVnNCZWNvbWluZyIsIm9uZVZzTWFueSIsIm1pbmRWc01hdHRlciIsImZyZWVkb21Wc0RldGVybWluaXNtIiwidHJhbnNjZW5kZW50VnNJbW1hbmVudCIsInJlYWxpc21Wc0FudGlSZWFsaXNtIiwicmVhc29uVnNFeHBlcmllbmNlIiwiYWJzb2x1dGVWc1JlbGF0aXZlIiwicmVkdWNlIiwic3VtIiwidmFsIiwibGVuZ3RoIiwicG9zaXRpb24iLCJ2YWx1ZU1hcCIsInRyYW5zZm9ybVBoaWxvc29waGVyRGF0YSIsInJhd0RhdGEiLCJtYXAiLCJyYXciLCJpZCIsImJpcnRoWWVhciIsImRlYXRoWWVhciIsInNwaXJhbER5bmFtaWNzU3RhZ2UiLCJzcGlyYWxKdXN0aWZpY2F0aW9uIiwic3dpdGNoUG9pbnRzIiwiZG9tYWluU3RyZW5ndGhzIiwiaW5mbHVlbmNlcyIsImNyaXRpcXVlcyIsImNvbXByZWhlbnNpdmVCaW9ncmFwaHkiLCJpbnRlbGxlY3R1YWxKb3VybmV5IiwicHJpbWFyeURvbWFpbiIsImJpcnRoTG9jYXRpb24iLCJhbGxEb21haW5zIiwiaGlzdG9yaWNhbENvbnRleHQiLCJzcGlyYWxUcmFuc2l0aW9ucyIsImdlbmVyYXRlQ29ubmVjdGlvbnMiLCJjb25uZWN0aW9ucyIsImZvckVhY2giLCJpbmZsdWVuY2VNYXAiLCJPYmplY3QiLCJlbnRyaWVzIiwic291cmNlSWQiLCJzdHJlbmd0aCIsInB1c2giLCJ0YXJnZXRJZCIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImNyaXRpcXVlTWFwIiwibG9hZFBoaWxvc29waGVyRGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImpzb24iLCJwaGlsb3NvcGhlcnMiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJmYWxsYmFja1Jlc3BvbnNlIiwiZmFsbGJhY2tEYXRhIiwiZmFsbGJhY2tFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/data/philosopher-loader.ts\n"));

/***/ })

}]);