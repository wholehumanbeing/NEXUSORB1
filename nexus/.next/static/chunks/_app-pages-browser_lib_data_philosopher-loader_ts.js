"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_data_philosopher-loader_ts"],{

/***/ "(app-pages-browser)/./lib/data/philosopher-loader.ts":
/*!****************************************!*\
  !*** ./lib/data/philosopher-loader.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateConnections: function() { return /* binding */ generateConnections; },\n/* harmony export */   loadPhilosopherData: function() { return /* binding */ loadPhilosopherData; },\n/* harmony export */   transformPhilosopherData: function() { return /* binding */ transformPhilosopherData; }\n/* harmony export */ });\n/**\n * Generates 3D position based on philosopher's characteristics\n */ function calculatePosition(philosopher, index, total) {\n    // Define distinct layers for each era\n    const eraLayers = {\n        \"Ancient\": 3,\n        \"Medieval\": 5,\n        \"Modern\": 7,\n        \"Contemporary\": 9 // Outermost layer\n    };\n    const baseRadius = eraLayers[philosopher.era] || 5;\n    // Calculate angle based on philosopher's position within their era\n    // Distribute philosophers evenly around the sphere for their era\n    const philosophersInEra = total; // This is approximate, could be refined\n    const angleStep = 2 * Math.PI / philosophersInEra;\n    const baseAngle = index * angleStep;\n    // Add some variation to avoid perfect grid\n    const angleVariation = (Math.random() - 0.5) * 0.3;\n    const angle = baseAngle + angleVariation;\n    // Use genome characteristics for vertical positioning with more variation\n    const genomeHeight = getGenomeHeight(philosopher.philosophicalGenome);\n    const heightVariation = (Math.random() - 0.5) * 0.5;\n    // Add slight radius variation to create organic feel\n    const radiusVariation = (Math.random() - 0.5) * 0.5;\n    const radius = baseRadius + radiusVariation;\n    // Calculate final position\n    const x = radius * Math.cos(angle);\n    const z = radius * Math.sin(angle);\n    const y = genomeHeight * 3 - 1.5 + heightVariation; // Range from -1.5 to 1.5\n    return [\n        x,\n        y,\n        z\n    ];\n}\n/**\n * Calculate height based on philosophical genome characteristics\n */ function getGenomeHeight(genome) {\n    // Map genome positions to numerical values for height calculation\n    const values = [\n        getGenomeValue(genome.beingVsBecoming),\n        getGenomeValue(genome.oneVsMany),\n        getGenomeValue(genome.mindVsMatter),\n        getGenomeValue(genome.freedomVsDeterminism),\n        getGenomeValue(genome.transcendentVsImmanent),\n        getGenomeValue(genome.realismVsAntiRealism),\n        getGenomeValue(genome.reasonVsExperience),\n        getGenomeValue(genome.absoluteVsRelative)\n    ];\n    return values.reduce((sum, val)=>sum + val, 0) / values.length;\n}\nfunction getGenomeValue(position) {\n    const valueMap = {\n        \"Being\": 0.2,\n        \"Becoming\": 0.8,\n        \"One\": 0.2,\n        \"Many\": 0.8,\n        \"Mind\": 0.2,\n        \"Matter\": 0.8,\n        \"Freedom\": 0.8,\n        \"Determinism\": 0.2,\n        \"Transcendent\": 0.8,\n        \"Immanent\": 0.2,\n        \"Realist\": 0.2,\n        \"Anti-realist\": 0.8,\n        \"Reason\": 0.2,\n        \"Experience\": 0.8,\n        \"Absolute\": 0.2,\n        \"Relative\": 0.8,\n        \"Both\": 0.5,\n        \"Dualist\": 0.5,\n        \"Synthesis\": 0.5\n    };\n    return valueMap[position] || 0.5;\n}\n/**\n * Transform raw philosopher data into PhilosopherNode format\n */ function transformPhilosopherData(rawData) {\n    return rawData.map((raw, index)=>({\n            id: raw.id,\n            name: raw.name,\n            birthYear: raw.birthYear,\n            deathYear: raw.deathYear,\n            position: calculatePosition(raw, index, rawData.length),\n            spiralDynamicsStage: raw.spiralDynamicsStage,\n            spiralJustification: raw.spiralJustification,\n            philosophicalGenome: {\n                beingVsBecoming: raw.philosophicalGenome.beingVsBecoming,\n                oneVsMany: raw.philosophicalGenome.oneVsMany,\n                mindVsMatter: raw.philosophicalGenome.mindVsMatter,\n                freedomVsDeterminism: raw.philosophicalGenome.freedomVsDeterminism,\n                transcendentVsImmanent: raw.philosophicalGenome.transcendentVsImmanent,\n                realismVsAntiRealism: raw.philosophicalGenome.realismVsAntiRealism,\n                reasonVsExperience: raw.philosophicalGenome.reasonVsExperience,\n                absoluteVsRelative: raw.philosophicalGenome.absoluteVsRelative\n            },\n            switchPoints: raw.switchPoints || [],\n            domainStrengths: raw.domainStrengths,\n            influences: raw.influences || [],\n            critiques: raw.critiques || [],\n            comprehensiveBiography: raw.comprehensiveBiography,\n            intellectualJourney: raw.intellectualJourney,\n            primaryDomain: raw.primaryDomain,\n            era: raw.era,\n            eraPosition: raw.eraPosition,\n            birthLocation: raw.birthLocation,\n            allDomains: raw.allDomains,\n            historicalContext: raw.historicalContext,\n            spiralTransitions: raw.spiralTransitions\n        }));\n}\n/**\n * Generate connections based on influence and critique relationships\n */ function generateConnections(rawData) {\n    const connections = [];\n    rawData.forEach((philosopher)=>{\n        // Process influences\n        if (philosopher.influenceMap) {\n            Object.entries(philosopher.influenceMap).forEach((param)=>{\n                let [sourceId, strength] = param;\n                connections.push({\n                    sourceId,\n                    targetId: philosopher.id,\n                    strength,\n                    type: \"influence\",\n                    description: \"Influences \".concat(philosopher.name, \"'s philosophical development\")\n                });\n            });\n        }\n        // Process critiques\n        if (philosopher.critiqueMap) {\n            Object.entries(philosopher.critiqueMap).forEach((param)=>{\n                let [targetId, strength] = param;\n                connections.push({\n                    sourceId: philosopher.id,\n                    targetId,\n                    strength,\n                    type: \"critique\",\n                    description: \"\".concat(philosopher.name, \" critiques this philosophical position\")\n                });\n            });\n        }\n    });\n    return connections;\n}\n/**\n * Load and process philosopher data from database API\n */ async function loadPhilosopherData() {\n    try {\n        const response = await fetch(\"/api/philosophers\");\n        if (!response.ok) {\n            throw new Error(\"Failed to load philosopher data: \".concat(response.statusText));\n        }\n        const rawData = await response.json();\n        const philosophers = transformPhilosopherData(rawData);\n        const connections = generateConnections(rawData);\n        console.log(\"Loaded \".concat(philosophers.length, \" philosophers and \").concat(connections.length, \" connections\"));\n        return {\n            philosophers,\n            connections\n        };\n    } catch (error) {\n        console.error(\"Error loading philosopher data:\", error);\n        // Fallback to JSON file if API fails\n        try {\n            const fallbackResponse = await fetch(\"/data/philosophers.json\");\n            if (fallbackResponse.ok) {\n                const fallbackData = await fallbackResponse.json();\n                const philosophers = transformPhilosopherData(fallbackData);\n                const connections = generateConnections(fallbackData);\n                console.log(\"Using fallback JSON data:\", philosophers.length, \"philosophers\");\n                return {\n                    philosophers,\n                    connections\n                };\n            }\n        } catch (fallbackError) {\n            console.error(\"Fallback also failed:\", fallbackError);\n        }\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhL3BoaWxvc29waGVyLWxvYWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUErQ0E7O0NBRUMsR0FDRCxTQUFTQSxrQkFBa0JDLFdBQStCLEVBQUVDLEtBQWEsRUFBRUMsS0FBYTtJQUN0RixzQ0FBc0M7SUFDdEMsTUFBTUMsWUFBb0M7UUFDeEMsV0FBVztRQUNYLFlBQVk7UUFDWixVQUFVO1FBQ1YsZ0JBQWdCLEVBQUcsa0JBQWtCO0lBQ3ZDO0lBRUEsTUFBTUMsYUFBYUQsU0FBUyxDQUFDSCxZQUFZSyxHQUFHLENBQUMsSUFBSTtJQUVqRCxtRUFBbUU7SUFDbkUsaUVBQWlFO0lBQ2pFLE1BQU1DLG9CQUFvQkosT0FBTyx3Q0FBd0M7SUFDekUsTUFBTUssWUFBWSxJQUFLQyxLQUFLQyxFQUFFLEdBQUlIO0lBQ2xDLE1BQU1JLFlBQVlULFFBQVFNO0lBRTFCLDJDQUEyQztJQUMzQyxNQUFNSSxpQkFBaUIsQ0FBQ0gsS0FBS0ksTUFBTSxLQUFLLEdBQUUsSUFBSztJQUMvQyxNQUFNQyxRQUFRSCxZQUFZQztJQUUxQiwwRUFBMEU7SUFDMUUsTUFBTUcsZUFBZUMsZ0JBQWdCZixZQUFZZ0IsbUJBQW1CO0lBQ3BFLE1BQU1DLGtCQUFrQixDQUFDVCxLQUFLSSxNQUFNLEtBQUssR0FBRSxJQUFLO0lBRWhELHFEQUFxRDtJQUNyRCxNQUFNTSxrQkFBa0IsQ0FBQ1YsS0FBS0ksTUFBTSxLQUFLLEdBQUUsSUFBSztJQUNoRCxNQUFNTyxTQUFTZixhQUFhYztJQUU1QiwyQkFBMkI7SUFDM0IsTUFBTUUsSUFBSUQsU0FBU1gsS0FBS2EsR0FBRyxDQUFDUjtJQUM1QixNQUFNUyxJQUFJSCxTQUFTWCxLQUFLZSxHQUFHLENBQUNWO0lBQzVCLE1BQU1XLElBQUksZUFBZ0IsSUFBSSxNQUFPUCxpQkFBaUIseUJBQXlCO0lBRS9FLE9BQU87UUFBQ0c7UUFBR0k7UUFBR0Y7S0FBRTtBQUNsQjtBQUVBOztDQUVDLEdBQ0QsU0FBU1As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QU1DLG1CQUFtQixNQUFNVCxNQUFNO1lBQ3JDLElBQUlTLGlCQUFpQlIsRUFBRSxFQUFFO2dCQUN2QixNQUFNUyxlQUFxQyxNQUFNRCxpQkFBaUJMLElBQUk7Z0JBQ3RFLE1BQU1DLGVBQWUxQyx5QkFBeUIrQztnQkFDOUMsTUFBTXhCLGNBQWNELG9CQUFvQnlCO2dCQUN4Q0osUUFBUUMsR0FBRyxDQUFDLDZCQUE2QkYsYUFBYTdDLE1BQU0sRUFBRTtnQkFDOUQsT0FBTztvQkFBRTZDO29CQUFjbkI7Z0JBQVk7WUFDckM7UUFDRixFQUFFLE9BQU95QixlQUFlO1lBQ3RCTCxRQUFRRSxLQUFLLENBQUMseUJBQXlCRztRQUN6QztRQUNBLE1BQU1IO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZGF0YS9waGlsb3NvcGhlci1sb2FkZXIudHM/OTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaGlsb3NvcGhlck5vZGUsIENvbm5lY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmF3UGhpbG9zb3BoZXJEYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBiaXJ0aFllYXI6IG51bWJlcjtcbiAgZGVhdGhZZWFyOiBudW1iZXI7XG4gIGJpcnRoTG9jYXRpb24/OiB7XG4gICAgY2l0eTogc3RyaW5nO1xuICAgIHJlZ2lvbjogc3RyaW5nO1xuICAgIG1vZGVybkNvdW50cnk6IHN0cmluZztcbiAgICBjb29yZGluYXRlczogW251bWJlciwgbnVtYmVyXTtcbiAgfTtcbiAgcHJpbWFyeURvbWFpbjogc3RyaW5nO1xuICBhbGxEb21haW5zPzogc3RyaW5nW107XG4gIGRvbWFpblN0cmVuZ3RoczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgZXJhOiBzdHJpbmc7XG4gIGVyYVBvc2l0aW9uOiBudW1iZXI7XG4gIHNwaXJhbER5bmFtaWNzU3RhZ2U6IHN0cmluZztcbiAgc3BpcmFsSnVzdGlmaWNhdGlvbjogc3RyaW5nO1xuICBzcGlyYWxUcmFuc2l0aW9ucz86IHN0cmluZ1tdO1xuICBwaGlsb3NvcGhpY2FsR2Vub21lOiB7XG4gICAgYmVpbmdWc0JlY29taW5nOiBzdHJpbmc7XG4gICAgb25lVnNNYW55OiBzdHJpbmc7XG4gICAgbWluZFZzTWF0dGVyOiBzdHJpbmc7XG4gICAgZnJlZWRvbVZzRGV0ZXJtaW5pc206IHN0cmluZztcbiAgICB0cmFuc2NlbmRlbnRWc0ltbWFuZW50OiBzdHJpbmc7XG4gICAgcmVhbGlzbVZzQW50aVJlYWxpc206IHN0cmluZztcbiAgICByZWFzb25Wc0V4cGVyaWVuY2U6IHN0cmluZztcbiAgICBhYnNvbHV0ZVZzUmVsYXRpdmU6IHN0cmluZztcbiAgICBnZW5vbWVKdXN0aWZpY2F0aW9ucz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIH07XG4gIHN3aXRjaFBvaW50cz86IEFycmF5PHtcbiAgICBxdWVzdGlvbjogc3RyaW5nO1xuICAgIHBvc2l0aW9uOiBzdHJpbmc7XG4gICAgYXJndW1lbnQ6IHN0cmluZztcbiAgICBkb21haW5DYXNjYWRlcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIH0+O1xuICBjb21wcmVoZW5zaXZlQmlvZ3JhcGh5OiBzdHJpbmc7XG4gIGludGVsbGVjdHVhbEpvdXJuZXk6IHN0cmluZztcbiAgaGlzdG9yaWNhbENvbnRleHQ/OiBzdHJpbmc7XG4gIGluZmx1ZW5jZXM/OiBzdHJpbmdbXTtcbiAgY3JpdGlxdWVzPzogc3RyaW5nW107XG4gIGluZmx1ZW5jZU1hcD86IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGNyaXRpcXVlTWFwPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgM0QgcG9zaXRpb24gYmFzZWQgb24gcGhpbG9zb3BoZXIncyBjaGFyYWN0ZXJpc3RpY3NcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb24ocGhpbG9zb3BoZXI6IFJhd1BoaWxvc29waGVyRGF0YSwgaW5kZXg6IG51bWJlciwgdG90YWw6IG51bWJlcik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIC8vIERlZmluZSBkaXN0aW5jdCBsYXllcnMgZm9yIGVhY2ggZXJhXG4gIGNvbnN0IGVyYUxheWVyczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAnQW5jaWVudCc6IDMsICAgICAgLy8gSW5uZXJtb3N0IGxheWVyXG4gICAgJ01lZGlldmFsJzogNSwgICAgIC8vIFNlY29uZCBsYXllclxuICAgICdNb2Rlcm4nOiA3LCAgICAgICAvLyBUaGlyZCBsYXllclxuICAgICdDb250ZW1wb3JhcnknOiA5ICAvLyBPdXRlcm1vc3QgbGF5ZXJcbiAgfTtcbiAgXG4gIGNvbnN0IGJhc2VSYWRpdXMgPSBlcmFMYXllcnNbcGhpbG9zb3BoZXIuZXJhXSB8fCA1O1xuICBcbiAgLy8gQ2FsY3VsYXRlIGFuZ2xlIGJhc2VkIG9uIHBoaWxvc29waGVyJ3MgcG9zaXRpb24gd2l0aGluIHRoZWlyIGVyYVxuICAvLyBEaXN0cmlidXRlIHBoaWxvc29waGVycyBldmVubHkgYXJvdW5kIHRoZSBzcGhlcmUgZm9yIHRoZWlyIGVyYVxuICBjb25zdCBwaGlsb3NvcGhlcnNJbkVyYSA9IHRvdGFsOyAvLyBUaGlzIGlzIGFwcHJveGltYXRlLCBjb3VsZCBiZSByZWZpbmVkXG4gIGNvbnN0IGFuZ2xlU3RlcCA9ICgyICogTWF0aC5QSSkgLyBwaGlsb3NvcGhlcnNJbkVyYTtcbiAgY29uc3QgYmFzZUFuZ2xlID0gaW5kZXggKiBhbmdsZVN0ZXA7XG4gIFxuICAvLyBBZGQgc29tZSB2YXJpYXRpb24gdG8gYXZvaWQgcGVyZmVjdCBncmlkXG4gIGNvbnN0IGFuZ2xlVmFyaWF0aW9uID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zO1xuICBjb25zdCBhbmdsZSA9IGJhc2VBbmdsZSArIGFuZ2xlVmFyaWF0aW9uO1xuICBcbiAgLy8gVXNlIGdlbm9tZSBjaGFyYWN0ZXJpc3RpY3MgZm9yIHZlcnRpY2FsIHBvc2l0aW9uaW5nIHdpdGggbW9yZSB2YXJpYXRpb25cbiAgY29uc3QgZ2Vub21lSGVpZ2h0ID0gZ2V0R2Vub21lSGVpZ2h0KHBoaWxvc29waGVyLnBoaWxvc29waGljYWxHZW5vbWUpO1xuICBjb25zdCBoZWlnaHRWYXJpYXRpb24gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjU7XG4gIFxuICAvLyBBZGQgc2xpZ2h0IHJhZGl1cyB2YXJpYXRpb24gdG8gY3JlYXRlIG9yZ2FuaWMgZmVlbFxuICBjb25zdCByYWRpdXNWYXJpYXRpb24gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjU7XG4gIGNvbnN0IHJhZGl1cyA9IGJhc2VSYWRpdXMgKyByYWRpdXNWYXJpYXRpb247XG4gIFxuICAvLyBDYWxjdWxhdGUgZmluYWwgcG9zaXRpb25cbiAgY29uc3QgeCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3QgeiA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgeSA9IChnZW5vbWVIZWlnaHQgKiAzIC0gMS41KSArIGhlaWdodFZhcmlhdGlvbjsgLy8gUmFuZ2UgZnJvbSAtMS41IHRvIDEuNVxuICBcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaGVpZ2h0IGJhc2VkIG9uIHBoaWxvc29waGljYWwgZ2Vub21lIGNoYXJhY3RlcmlzdGljc1xuICovXG5mdW5jdGlvbiBnZXRHZW5vbWVIZWlnaHQoZ2Vub21lOiBSYXdQaGlsb3NvcGhlckRhdGFbJ3BoaWxvc29waGljYWxHZW5vbWUnXSk6IG51bWJlciB7XG4gIC8vIE1hcCBnZW5vbWUgcG9zaXRpb25zIHRvIG51bWVyaWNhbCB2YWx1ZXMgZm9yIGhlaWdodCBjYWxjdWxhdGlvblxuICBjb25zdCB2YWx1ZXMgPSBbXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLmJlaW5nVnNCZWNvbWluZyksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLm9uZVZzTWFueSksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLm1pbmRWc01hdHRlciksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLmZyZWVkb21Wc0RldGVybWluaXNtKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUudHJhbnNjZW5kZW50VnNJbW1hbmVudCksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLnJlYWxpc21Wc0FudGlSZWFsaXNtKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUucmVhc29uVnNFeHBlcmllbmNlKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUuYWJzb2x1dGVWc1JlbGF0aXZlKVxuICBdO1xuICBcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0R2Vub21lVmFsdWUocG9zaXRpb246IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHZhbHVlTWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICdCZWluZyc6IDAuMixcbiAgICAnQmVjb21pbmcnOiAwLjgsXG4gICAgJ09uZSc6IDAuMixcbiAgICAnTWFueSc6IDAuOCxcbiAgICAnTWluZCc6IDAuMixcbiAgICAnTWF0dGVyJzogMC44LFxuICAgICdGcmVlZG9tJzogMC44LFxuICAgICdEZXRlcm1pbmlzbSc6IDAuMixcbiAgICAnVHJhbnNjZW5kZW50JzogMC44LFxuICAgICdJbW1hbmVudCc6IDAuMixcbiAgICAnUmVhbGlzdCc6IDAuMixcbiAgICAnQW50aS1yZWFsaXN0JzogMC44LFxuICAgICdSZWFzb24nOiAwLjIsXG4gICAgJ0V4cGVyaWVuY2UnOiAwLjgsXG4gICAgJ0Fic29sdXRlJzogMC4yLFxuICAgICdSZWxhdGl2ZSc6IDAuOCxcbiAgICAnQm90aCc6IDAuNSxcbiAgICAnRHVhbGlzdCc6IDAuNSxcbiAgICAnU3ludGhlc2lzJzogMC41XG4gIH07XG4gIFxuICByZXR1cm4gdmFsdWVNYXBbcG9zaXRpb25dIHx8IDAuNTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gcmF3IHBoaWxvc29waGVyIGRhdGEgaW50byBQaGlsb3NvcGhlck5vZGUgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1QaGlsb3NvcGhlckRhdGEocmF3RGF0YTogUmF3UGhpbG9zb3BoZXJEYXRhW10pOiBQaGlsb3NvcGhlck5vZGVbXSB7XG4gIHJldHVybiByYXdEYXRhLm1hcCgocmF3LCBpbmRleCkgPT4gKHtcbiAgICBpZDogcmF3LmlkLFxuICAgIG5hbWU6IHJhdy5uYW1lLFxuICAgIGJpcnRoWWVhcjogcmF3LmJpcnRoWWVhcixcbiAgICBkZWF0aFllYXI6IHJhdy5kZWF0aFllYXIsXG4gICAgcG9zaXRpb246IGNhbGN1bGF0ZVBvc2l0aW9uKHJhdywgaW5kZXgsIHJhd0RhdGEubGVuZ3RoKSxcbiAgICBzcGlyYWxEeW5hbWljc1N0YWdlOiByYXcuc3BpcmFsRHluYW1pY3NTdGFnZSxcbiAgICBzcGlyYWxKdXN0aWZpY2F0aW9uOiByYXcuc3BpcmFsSnVzdGlmaWNhdGlvbixcbiAgICBwaGlsb3NvcGhpY2FsR2Vub21lOiB7XG4gICAgICBiZWluZ1ZzQmVjb21pbmc6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLmJlaW5nVnNCZWNvbWluZyBhcyBhbnksXG4gICAgICBvbmVWc01hbnk6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLm9uZVZzTWFueSBhcyBhbnksXG4gICAgICBtaW5kVnNNYXR0ZXI6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLm1pbmRWc01hdHRlciBhcyBhbnksXG4gICAgICBmcmVlZG9tVnNEZXRlcm1pbmlzbTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUuZnJlZWRvbVZzRGV0ZXJtaW5pc20gYXMgYW55LFxuICAgICAgdHJhbnNjZW5kZW50VnNJbW1hbmVudDogcmF3LnBoaWxvc29waGljYWxHZW5vbWUudHJhbnNjZW5kZW50VnNJbW1hbmVudCBhcyBhbnksXG4gICAgICByZWFsaXNtVnNBbnRpUmVhbGlzbTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUucmVhbGlzbVZzQW50aVJlYWxpc20gYXMgYW55LFxuICAgICAgcmVhc29uVnNFeHBlcmllbmNlOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5yZWFzb25Wc0V4cGVyaWVuY2UgYXMgYW55LFxuICAgICAgYWJzb2x1dGVWc1JlbGF0aXZlOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5hYnNvbHV0ZVZzUmVsYXRpdmUgYXMgYW55LFxuICAgIH0sXG4gICAgc3dpdGNoUG9pbnRzOiByYXcuc3dpdGNoUG9pbnRzIHx8IFtdLFxuICAgIGRvbWFpblN0cmVuZ3RoczogcmF3LmRvbWFpblN0cmVuZ3RocyxcbiAgICBpbmZsdWVuY2VzOiByYXcuaW5mbHVlbmNlcyB8fCBbXSxcbiAgICBjcml0aXF1ZXM6IHJhdy5jcml0aXF1ZXMgfHwgW10sXG4gICAgY29tcHJlaGVuc2l2ZUJpb2dyYXBoeTogcmF3LmNvbXByZWhlbnNpdmVCaW9ncmFwaHksXG4gICAgaW50ZWxsZWN0dWFsSm91cm5leTogcmF3LmludGVsbGVjdHVhbEpvdXJuZXksXG4gICAgcHJpbWFyeURvbWFpbjogcmF3LnByaW1hcnlEb21haW4sXG4gICAgZXJhOiByYXcuZXJhIGFzIGFueSxcbiAgICBlcmFQb3NpdGlvbjogcmF3LmVyYVBvc2l0aW9uLFxuICAgIGJpcnRoTG9jYXRpb246IHJhdy5iaXJ0aExvY2F0aW9uLFxuICAgIGFsbERvbWFpbnM6IHJhdy5hbGxEb21haW5zLFxuICAgIGhpc3RvcmljYWxDb250ZXh0OiByYXcuaGlzdG9yaWNhbENvbnRleHQsXG4gICAgc3BpcmFsVHJhbnNpdGlvbnM6IHJhdy5zcGlyYWxUcmFuc2l0aW9uc1xuICB9KSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY29ubmVjdGlvbnMgYmFzZWQgb24gaW5mbHVlbmNlIGFuZCBjcml0aXF1ZSByZWxhdGlvbnNoaXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNvbm5lY3Rpb25zKHJhd0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdKTogQ29ubmVjdGlvbltdIHtcbiAgY29uc3QgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSA9IFtdO1xuICBcbiAgcmF3RGF0YS5mb3JFYWNoKHBoaWxvc29waGVyID0+IHtcbiAgICAvLyBQcm9jZXNzIGluZmx1ZW5jZXNcbiAgICBpZiAocGhpbG9zb3BoZXIuaW5mbHVlbmNlTWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhwaGlsb3NvcGhlci5pbmZsdWVuY2VNYXApLmZvckVhY2goKFtzb3VyY2VJZCwgc3RyZW5ndGhdKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHNvdXJjZUlkLFxuICAgICAgICAgIHRhcmdldElkOiBwaGlsb3NvcGhlci5pZCxcbiAgICAgICAgICBzdHJlbmd0aCxcbiAgICAgICAgICB0eXBlOiAnaW5mbHVlbmNlJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEluZmx1ZW5jZXMgJHtwaGlsb3NvcGhlci5uYW1lfSdzIHBoaWxvc29waGljYWwgZGV2ZWxvcG1lbnRgXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFByb2Nlc3MgY3JpdGlxdWVzXG4gICAgaWYgKHBoaWxvc29waGVyLmNyaXRpcXVlTWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhwaGlsb3NvcGhlci5jcml0aXF1ZU1hcCkuZm9yRWFjaCgoW3RhcmdldElkLCBzdHJlbmd0aF0pID0+IHtcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgc291cmNlSWQ6IHBoaWxvc29waGVyLmlkLFxuICAgICAgICAgIHRhcmdldElkLFxuICAgICAgICAgIHN0cmVuZ3RoLFxuICAgICAgICAgIHR5cGU6ICdjcml0aXF1ZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGAke3BoaWxvc29waGVyLm5hbWV9IGNyaXRpcXVlcyB0aGlzIHBoaWxvc29waGljYWwgcG9zaXRpb25gXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBjb25uZWN0aW9ucztcbn1cblxuLyoqXG4gKiBMb2FkIGFuZCBwcm9jZXNzIHBoaWxvc29waGVyIGRhdGEgZnJvbSBkYXRhYmFzZSBBUElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQaGlsb3NvcGhlckRhdGEoKTogUHJvbWlzZTx7IHBoaWxvc29waGVyczogUGhpbG9zb3BoZXJOb2RlW10sIGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10gfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcGhpbG9zb3BoZXJzJyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBwaGlsb3NvcGhlciBkYXRhOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJhd0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGNvbnN0IHBoaWxvc29waGVycyA9IHRyYW5zZm9ybVBoaWxvc29waGVyRGF0YShyYXdEYXRhKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IGdlbmVyYXRlQ29ubmVjdGlvbnMocmF3RGF0YSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYExvYWRlZCAke3BoaWxvc29waGVycy5sZW5ndGh9IHBoaWxvc29waGVycyBhbmQgJHtjb25uZWN0aW9ucy5sZW5ndGh9IGNvbm5lY3Rpb25zYCk7XG4gICAgXG4gICAgcmV0dXJuIHsgcGhpbG9zb3BoZXJzLCBjb25uZWN0aW9ucyB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcGhpbG9zb3BoZXIgZGF0YTonLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2sgdG8gSlNPTiBmaWxlIGlmIEFQSSBmYWlsc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9kYXRhL3BoaWxvc29waGVycy5qc29uJyk7XG4gICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBmYWxsYmFja0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdID0gYXdhaXQgZmFsbGJhY2tSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHBoaWxvc29waGVycyA9IHRyYW5zZm9ybVBoaWxvc29waGVyRGF0YShmYWxsYmFja0RhdGEpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGdlbmVyYXRlQ29ubmVjdGlvbnMoZmFsbGJhY2tEYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGZhbGxiYWNrIEpTT04gZGF0YTonLCBwaGlsb3NvcGhlcnMubGVuZ3RoLCAncGhpbG9zb3BoZXJzJyk7XG4gICAgICAgIHJldHVybiB7IHBoaWxvc29waGVycywgY29ubmVjdGlvbnMgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWxsYmFjayBhbHNvIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0iXSwibmFtZXMiOlsiY2FsY3VsYXRlUG9zaXRpb24iLCJwaGlsb3NvcGhlciIsImluZGV4IiwidG90YWwiLCJlcmFMYXllcnMiLCJiYXNlUmFkaXVzIiwiZXJhIiwicGhpbG9zb3BoZXJzSW5FcmEiLCJhbmdsZVN0ZXAiLCJNYXRoIiwiUEkiLCJiYXNlQW5nbGUiLCJhbmdsZVZhcmlhdGlvbiIsInJhbmRvbSIsImFuZ2xlIiwiZ2Vub21lSGVpZ2h0IiwiZ2V0R2Vub21lSGVpZ2h0IiwicGhpbG9zb3BoaWNhbEdlbm9tZSIsImhlaWdodFZhcmlhdGlvbiIsInJhZGl1c1ZhcmlhdGlvbiIsInJhZGl1cyIsIngiLCJjb3MiLCJ6Iiwic2luIiwieSIsImdlbm9tZSIsInZhbHVlcyIsImdldEdlbm9tZVZhbHVlIiwiYmVpbmdWc0JlY29taW5nIiwib25lVnNNYW55IiwibWluZFZzTWF0dGVyIiwiZnJlZWRvbVZzRGV0ZXJtaW5pc20iLCJ0cmFuc2NlbmRlbnRWc0ltbWFuZW50IiwicmVhbGlzbVZzQW50aVJlYWxpc20iLCJyZWFzb25Wc0V4cGVyaWVuY2UiLCJhYnNvbHV0ZVZzUmVsYXRpdmUiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJsZW5ndGgiLCJwb3NpdGlvbiIsInZhbHVlTWFwIiwidHJhbnNmb3JtUGhpbG9zb3BoZXJEYXRhIiwicmF3RGF0YSIsIm1hcCIsInJhdyIsImlkIiwibmFtZSIsImJpcnRoWWVhciIsImRlYXRoWWVhciIsInNwaXJhbER5bmFtaWNzU3RhZ2UiLCJzcGlyYWxKdXN0aWZpY2F0aW9uIiwic3dpdGNoUG9pbnRzIiwiZG9tYWluU3RyZW5ndGhzIiwiaW5mbHVlbmNlcyIsImNyaXRpcXVlcyIsImNvbXByZWhlbnNpdmVCaW9ncmFwaHkiLCJpbnRlbGxlY3R1YWxKb3VybmV5IiwicHJpbWFyeURvbWFpbiIsImVyYVBvc2l0aW9uIiwiYmlydGhMb2NhdGlvbiIsImFsbERvbWFpbnMiLCJoaXN0b3JpY2FsQ29udGV4dCIsInNwaXJhbFRyYW5zaXRpb25zIiwiZ2VuZXJhdGVDb25uZWN0aW9ucyIsImNvbm5lY3Rpb25zIiwiZm9yRWFjaCIsImluZmx1ZW5jZU1hcCIsIk9iamVjdCIsImVudHJpZXMiLCJzb3VyY2VJZCIsInN0cmVuZ3RoIiwicHVzaCIsInRhcmdldElkIiwidHlwZSIsImRlc2NyaXB0aW9uIiwiY3JpdGlxdWVNYXAiLCJsb2FkUGhpbG9zb3BoZXJEYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwianNvbiIsInBoaWxvc29waGVycyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImZhbGxiYWNrUmVzcG9uc2UiLCJmYWxsYmFja0RhdGEiLCJmYWxsYmFja0Vycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/data/philosopher-loader.ts\n"));

/***/ })

}]);