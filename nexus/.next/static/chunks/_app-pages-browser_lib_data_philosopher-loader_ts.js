"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_data_philosopher-loader_ts"],{

/***/ "(app-pages-browser)/./lib/data/philosopher-loader.ts":
/*!****************************************!*\
  !*** ./lib/data/philosopher-loader.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateConnections: function() { return /* binding */ generateConnections; },\n/* harmony export */   loadPhilosopherData: function() { return /* binding */ loadPhilosopherData; },\n/* harmony export */   transformPhilosopherData: function() { return /* binding */ transformPhilosopherData; }\n/* harmony export */ });\n/**\n * Generates 3D position based on philosopher's characteristics\n */ function calculatePosition(philosopher, index, total) {\n    // Use era and primary characteristics to position in 3D space\n    const eraRadius = philosopher.eraPosition * 8; // Scale era position to radius\n    // Map era to angle ranges\n    const eraAngles = {\n        \"Ancient\": [\n            0,\n            Math.PI / 2\n        ],\n        \"Medieval\": [\n            Math.PI / 2,\n            Math.PI\n        ],\n        \"Modern\": [\n            Math.PI,\n            3 * Math.PI / 2\n        ],\n        \"Contemporary\": [\n            3 * Math.PI / 2,\n            2 * Math.PI\n        ]\n    };\n    const [minAngle, maxAngle] = eraAngles[philosopher.era] || [\n        0,\n        2 * Math.PI\n    ];\n    const angle = minAngle + philosopher.eraPosition * (maxAngle - minAngle);\n    // Use genome characteristics for height positioning\n    const genomeHeight = getGenomeHeight(philosopher.philosophicalGenome);\n    // Add some randomness based on philosopher's unique characteristics\n    const uniqueOffset = philosopher.name.charCodeAt(0) % 100 / 100;\n    const x = eraRadius * Math.cos(angle) + uniqueOffset;\n    const z = eraRadius * Math.sin(angle) + uniqueOffset;\n    const y = genomeHeight * 4 - 2; // Range from -2 to 2\n    return [\n        x,\n        y,\n        z\n    ];\n}\n/**\n * Calculate height based on philosophical genome characteristics\n */ function getGenomeHeight(genome) {\n    // Map genome positions to numerical values for height calculation\n    const values = [\n        getGenomeValue(genome.beingVsBecoming),\n        getGenomeValue(genome.oneVsMany),\n        getGenomeValue(genome.mindVsMatter),\n        getGenomeValue(genome.freedomVsDeterminism),\n        getGenomeValue(genome.transcendentVsImmanent),\n        getGenomeValue(genome.realismVsAntiRealism),\n        getGenomeValue(genome.reasonVsExperience),\n        getGenomeValue(genome.absoluteVsRelative)\n    ];\n    return values.reduce((sum, val)=>sum + val, 0) / values.length;\n}\nfunction getGenomeValue(position) {\n    const valueMap = {\n        \"Being\": 0.2,\n        \"Becoming\": 0.8,\n        \"One\": 0.2,\n        \"Many\": 0.8,\n        \"Mind\": 0.2,\n        \"Matter\": 0.8,\n        \"Freedom\": 0.8,\n        \"Determinism\": 0.2,\n        \"Transcendent\": 0.8,\n        \"Immanent\": 0.2,\n        \"Realist\": 0.2,\n        \"Anti-realist\": 0.8,\n        \"Reason\": 0.2,\n        \"Experience\": 0.8,\n        \"Absolute\": 0.2,\n        \"Relative\": 0.8,\n        \"Both\": 0.5,\n        \"Dualist\": 0.5,\n        \"Synthesis\": 0.5\n    };\n    return valueMap[position] || 0.5;\n}\n/**\n * Transform raw philosopher data into PhilosopherNode format\n */ function transformPhilosopherData(rawData) {\n    return rawData.map((raw, index)=>({\n            id: raw.id,\n            name: raw.name,\n            birthYear: raw.birthYear,\n            deathYear: raw.deathYear,\n            position: calculatePosition(raw, index, rawData.length),\n            spiralDynamicsStage: raw.spiralDynamicsStage,\n            spiralJustification: raw.spiralJustification,\n            philosophicalGenome: {\n                beingVsBecoming: raw.philosophicalGenome.beingVsBecoming,\n                oneVsMany: raw.philosophicalGenome.oneVsMany,\n                mindVsMatter: raw.philosophicalGenome.mindVsMatter,\n                freedomVsDeterminism: raw.philosophicalGenome.freedomVsDeterminism,\n                transcendentVsImmanent: raw.philosophicalGenome.transcendentVsImmanent,\n                realismVsAntiRealism: raw.philosophicalGenome.realismVsAntiRealism,\n                reasonVsExperience: raw.philosophicalGenome.reasonVsExperience,\n                absoluteVsRelative: raw.philosophicalGenome.absoluteVsRelative\n            },\n            switchPoints: raw.switchPoints || [],\n            domainStrengths: raw.domainStrengths,\n            influences: raw.influences || [],\n            critiques: raw.critiques || [],\n            comprehensiveBiography: raw.comprehensiveBiography,\n            intellectualJourney: raw.intellectualJourney,\n            primaryDomain: raw.primaryDomain,\n            era: raw.era,\n            eraPosition: raw.eraPosition,\n            birthLocation: raw.birthLocation,\n            allDomains: raw.allDomains,\n            historicalContext: raw.historicalContext,\n            spiralTransitions: raw.spiralTransitions\n        }));\n}\n/**\n * Generate connections based on influence and critique relationships\n */ function generateConnections(rawData) {\n    const connections = [];\n    rawData.forEach((philosopher)=>{\n        // Process influences\n        if (philosopher.influenceMap) {\n            Object.entries(philosopher.influenceMap).forEach((param)=>{\n                let [sourceId, strength] = param;\n                connections.push({\n                    sourceId,\n                    targetId: philosopher.id,\n                    strength,\n                    type: \"influence\",\n                    description: \"Influences \".concat(philosopher.name, \"'s philosophical development\")\n                });\n            });\n        }\n        // Process critiques\n        if (philosopher.critiqueMap) {\n            Object.entries(philosopher.critiqueMap).forEach((param)=>{\n                let [targetId, strength] = param;\n                connections.push({\n                    sourceId: philosopher.id,\n                    targetId,\n                    strength,\n                    type: \"critique\",\n                    description: \"\".concat(philosopher.name, \" critiques this philosophical position\")\n                });\n            });\n        }\n    });\n    return connections;\n}\n/**\n * Load and process philosopher data from JSON file\n */ async function loadPhilosopherData() {\n    try {\n        const response = await fetch(\"/data/philosophers.json\");\n        if (!response.ok) {\n            throw new Error(\"Failed to load philosopher data: \".concat(response.statusText));\n        }\n        const rawData = await response.json();\n        const philosophers = transformPhilosopherData(rawData);\n        const connections = generateConnections(rawData);\n        console.log(\"Loaded \".concat(philosophers.length, \" philosophers and \").concat(connections.length, \" connections\"));\n        return {\n            philosophers,\n            connections\n        };\n    } catch (error) {\n        console.error(\"Error loading philosopher data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYXRhL3BoaWxvc29waGVyLWxvYWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUErQ0E7O0NBRUMsR0FDRCxTQUFTQSxrQkFBa0JDLFdBQStCLEVBQUVDLEtBQWEsRUFBRUMsS0FBYTtJQUN0Riw4REFBOEQ7SUFDOUQsTUFBTUMsWUFBWUgsWUFBWUksV0FBVyxHQUFHLEdBQUcsK0JBQStCO0lBRTlFLDBCQUEwQjtJQUMxQixNQUFNQyxZQUE4QztRQUNsRCxXQUFXO1lBQUM7WUFBR0MsS0FBS0MsRUFBRSxHQUFHO1NBQUU7UUFDM0IsWUFBWTtZQUFDRCxLQUFLQyxFQUFFLEdBQUc7WUFBR0QsS0FBS0MsRUFBRTtTQUFDO1FBQ2xDLFVBQVU7WUFBQ0QsS0FBS0MsRUFBRTtZQUFFLElBQUlELEtBQUtDLEVBQUUsR0FBRztTQUFFO1FBQ3BDLGdCQUFnQjtZQUFDLElBQUlELEtBQUtDLEVBQUUsR0FBRztZQUFHLElBQUlELEtBQUtDLEVBQUU7U0FBQztJQUNoRDtJQUVBLE1BQU0sQ0FBQ0MsVUFBVUMsU0FBUyxHQUFHSixTQUFTLENBQUNMLFlBQVlVLEdBQUcsQ0FBQyxJQUFJO1FBQUM7UUFBRyxJQUFJSixLQUFLQyxFQUFFO0tBQUM7SUFDM0UsTUFBTUksUUFBUUgsV0FBWVIsWUFBWUksV0FBVyxHQUFJSyxDQUFBQSxXQUFXRCxRQUFPO0lBRXZFLG9EQUFvRDtJQUNwRCxNQUFNSSxlQUFlQyxnQkFBZ0JiLFlBQVljLG1CQUFtQjtJQUVwRSxvRUFBb0U7SUFDcEUsTUFBTUMsZUFBZSxZQUFhQyxJQUFJLENBQUNDLFVBQVUsQ0FBQyxLQUFLLE1BQU87SUFFOUQsTUFBTUMsSUFBSWYsWUFBWUcsS0FBS2EsR0FBRyxDQUFDUixTQUFTSTtJQUN4QyxNQUFNSyxJQUFJakIsWUFBWUcsS0FBS2UsR0FBRyxDQUFDVixTQUFTSTtJQUN4QyxNQUFNTyxJQUFJVixlQUFlLElBQUksR0FBRyxxQkFBcUI7SUFFckQsT0FBTztRQUFDTTtR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SyxDQUFDLG1DQUFtQ0E7UUFDakQsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9kYXRhL3BoaWxvc29waGVyLWxvYWRlci50cz85M2ZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBoaWxvc29waGVyTm9kZSwgQ29ubmVjdGlvbiB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBSYXdQaGlsb3NvcGhlckRhdGEge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGJpcnRoWWVhcjogbnVtYmVyO1xuICBkZWF0aFllYXI6IG51bWJlcjtcbiAgYmlydGhMb2NhdGlvbj86IHtcbiAgICBjaXR5OiBzdHJpbmc7XG4gICAgcmVnaW9uOiBzdHJpbmc7XG4gICAgbW9kZXJuQ291bnRyeTogc3RyaW5nO1xuICAgIGNvb3JkaW5hdGVzOiBbbnVtYmVyLCBudW1iZXJdO1xuICB9O1xuICBwcmltYXJ5RG9tYWluOiBzdHJpbmc7XG4gIGFsbERvbWFpbnM/OiBzdHJpbmdbXTtcbiAgZG9tYWluU3RyZW5ndGhzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICBlcmE6IHN0cmluZztcbiAgZXJhUG9zaXRpb246IG51bWJlcjtcbiAgc3BpcmFsRHluYW1pY3NTdGFnZTogc3RyaW5nO1xuICBzcGlyYWxKdXN0aWZpY2F0aW9uOiBzdHJpbmc7XG4gIHNwaXJhbFRyYW5zaXRpb25zPzogc3RyaW5nW107XG4gIHBoaWxvc29waGljYWxHZW5vbWU6IHtcbiAgICBiZWluZ1ZzQmVjb21pbmc6IHN0cmluZztcbiAgICBvbmVWc01hbnk6IHN0cmluZztcbiAgICBtaW5kVnNNYXR0ZXI6IHN0cmluZztcbiAgICBmcmVlZG9tVnNEZXRlcm1pbmlzbTogc3RyaW5nO1xuICAgIHRyYW5zY2VuZGVudFZzSW1tYW5lbnQ6IHN0cmluZztcbiAgICByZWFsaXNtVnNBbnRpUmVhbGlzbTogc3RyaW5nO1xuICAgIHJlYXNvblZzRXhwZXJpZW5jZTogc3RyaW5nO1xuICAgIGFic29sdXRlVnNSZWxhdGl2ZTogc3RyaW5nO1xuICAgIGdlbm9tZUp1c3RpZmljYXRpb25zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgfTtcbiAgc3dpdGNoUG9pbnRzPzogQXJyYXk8e1xuICAgIHF1ZXN0aW9uOiBzdHJpbmc7XG4gICAgcG9zaXRpb246IHN0cmluZztcbiAgICBhcmd1bWVudDogc3RyaW5nO1xuICAgIGRvbWFpbkNhc2NhZGVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgfT47XG4gIGNvbXByZWhlbnNpdmVCaW9ncmFwaHk6IHN0cmluZztcbiAgaW50ZWxsZWN0dWFsSm91cm5leTogc3RyaW5nO1xuICBoaXN0b3JpY2FsQ29udGV4dD86IHN0cmluZztcbiAgaW5mbHVlbmNlcz86IHN0cmluZ1tdO1xuICBjcml0aXF1ZXM/OiBzdHJpbmdbXTtcbiAgaW5mbHVlbmNlTWFwPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgY3JpdGlxdWVNYXA/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyAzRCBwb3NpdGlvbiBiYXNlZCBvbiBwaGlsb3NvcGhlcidzIGNoYXJhY3RlcmlzdGljc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbihwaGlsb3NvcGhlcjogUmF3UGhpbG9zb3BoZXJEYXRhLCBpbmRleDogbnVtYmVyLCB0b3RhbDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgLy8gVXNlIGVyYSBhbmQgcHJpbWFyeSBjaGFyYWN0ZXJpc3RpY3MgdG8gcG9zaXRpb24gaW4gM0Qgc3BhY2VcbiAgY29uc3QgZXJhUmFkaXVzID0gcGhpbG9zb3BoZXIuZXJhUG9zaXRpb24gKiA4OyAvLyBTY2FsZSBlcmEgcG9zaXRpb24gdG8gcmFkaXVzXG4gIFxuICAvLyBNYXAgZXJhIHRvIGFuZ2xlIHJhbmdlc1xuICBjb25zdCBlcmFBbmdsZXM6IFJlY29yZDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+ID0ge1xuICAgICdBbmNpZW50JzogWzAsIE1hdGguUEkgLyAyXSxcbiAgICAnTWVkaWV2YWwnOiBbTWF0aC5QSSAvIDIsIE1hdGguUEldLFxuICAgICdNb2Rlcm4nOiBbTWF0aC5QSSwgMyAqIE1hdGguUEkgLyAyXSxcbiAgICAnQ29udGVtcG9yYXJ5JzogWzMgKiBNYXRoLlBJIC8gMiwgMiAqIE1hdGguUEldXG4gIH07XG4gIFxuICBjb25zdCBbbWluQW5nbGUsIG1heEFuZ2xlXSA9IGVyYUFuZ2xlc1twaGlsb3NvcGhlci5lcmFdIHx8IFswLCAyICogTWF0aC5QSV07XG4gIGNvbnN0IGFuZ2xlID0gbWluQW5nbGUgKyAocGhpbG9zb3BoZXIuZXJhUG9zaXRpb24gKiAobWF4QW5nbGUgLSBtaW5BbmdsZSkpO1xuICBcbiAgLy8gVXNlIGdlbm9tZSBjaGFyYWN0ZXJpc3RpY3MgZm9yIGhlaWdodCBwb3NpdGlvbmluZ1xuICBjb25zdCBnZW5vbWVIZWlnaHQgPSBnZXRHZW5vbWVIZWlnaHQocGhpbG9zb3BoZXIucGhpbG9zb3BoaWNhbEdlbm9tZSk7XG4gIFxuICAvLyBBZGQgc29tZSByYW5kb21uZXNzIGJhc2VkIG9uIHBoaWxvc29waGVyJ3MgdW5pcXVlIGNoYXJhY3RlcmlzdGljc1xuICBjb25zdCB1bmlxdWVPZmZzZXQgPSAocGhpbG9zb3BoZXIubmFtZS5jaGFyQ29kZUF0KDApICUgMTAwKSAvIDEwMDtcbiAgXG4gIGNvbnN0IHggPSBlcmFSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkgKyB1bmlxdWVPZmZzZXQ7XG4gIGNvbnN0IHogPSBlcmFSYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyB1bmlxdWVPZmZzZXQ7XG4gIGNvbnN0IHkgPSBnZW5vbWVIZWlnaHQgKiA0IC0gMjsgLy8gUmFuZ2UgZnJvbSAtMiB0byAyXG4gIFxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBoZWlnaHQgYmFzZWQgb24gcGhpbG9zb3BoaWNhbCBnZW5vbWUgY2hhcmFjdGVyaXN0aWNzXG4gKi9cbmZ1bmN0aW9uIGdldEdlbm9tZUhlaWdodChnZW5vbWU6IFJhd1BoaWxvc29waGVyRGF0YVsncGhpbG9zb3BoaWNhbEdlbm9tZSddKTogbnVtYmVyIHtcbiAgLy8gTWFwIGdlbm9tZSBwb3NpdGlvbnMgdG8gbnVtZXJpY2FsIHZhbHVlcyBmb3IgaGVpZ2h0IGNhbGN1bGF0aW9uXG4gIGNvbnN0IHZhbHVlcyA9IFtcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUuYmVpbmdWc0JlY29taW5nKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUub25lVnNNYW55KSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUubWluZFZzTWF0dGVyKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUuZnJlZWRvbVZzRGV0ZXJtaW5pc20pLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS50cmFuc2NlbmRlbnRWc0ltbWFuZW50KSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUucmVhbGlzbVZzQW50aVJlYWxpc20pLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5yZWFzb25Wc0V4cGVyaWVuY2UpLFxuICAgIGdldEdlbm9tZVZhbHVlKGdlbm9tZS5hYnNvbHV0ZVZzUmVsYXRpdmUpXG4gIF07XG4gIFxuICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRHZW5vbWVWYWx1ZShwb3NpdGlvbjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgdmFsdWVNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgJ0JlaW5nJzogMC4yLFxuICAgICdCZWNvbWluZyc6IDAuOCxcbiAgICAnT25lJzogMC4yLFxuICAgICdNYW55JzogMC44LFxuICAgICdNaW5kJzogMC4yLFxuICAgICdNYXR0ZXInOiAwLjgsXG4gICAgJ0ZyZWVkb20nOiAwLjgsXG4gICAgJ0RldGVybWluaXNtJzogMC4yLFxuICAgICdUcmFuc2NlbmRlbnQnOiAwLjgsXG4gICAgJ0ltbWFuZW50JzogMC4yLFxuICAgICdSZWFsaXN0JzogMC4yLFxuICAgICdBbnRpLXJlYWxpc3QnOiAwLjgsXG4gICAgJ1JlYXNvbic6IDAuMixcbiAgICAnRXhwZXJpZW5jZSc6IDAuOCxcbiAgICAnQWJzb2x1dGUnOiAwLjIsXG4gICAgJ1JlbGF0aXZlJzogMC44LFxuICAgICdCb3RoJzogMC41LFxuICAgICdEdWFsaXN0JzogMC41LFxuICAgICdTeW50aGVzaXMnOiAwLjVcbiAgfTtcbiAgXG4gIHJldHVybiB2YWx1ZU1hcFtwb3NpdGlvbl0gfHwgMC41O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSByYXcgcGhpbG9zb3BoZXIgZGF0YSBpbnRvIFBoaWxvc29waGVyTm9kZSBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVBoaWxvc29waGVyRGF0YShyYXdEYXRhOiBSYXdQaGlsb3NvcGhlckRhdGFbXSk6IFBoaWxvc29waGVyTm9kZVtdIHtcbiAgcmV0dXJuIHJhd0RhdGEubWFwKChyYXcsIGluZGV4KSA9PiAoe1xuICAgIGlkOiByYXcuaWQsXG4gICAgbmFtZTogcmF3Lm5hbWUsXG4gICAgYmlydGhZZWFyOiByYXcuYmlydGhZZWFyLFxuICAgIGRlYXRoWWVhcjogcmF3LmRlYXRoWWVhcixcbiAgICBwb3NpdGlvbjogY2FsY3VsYXRlUG9zaXRpb24ocmF3LCBpbmRleCwgcmF3RGF0YS5sZW5ndGgpLFxuICAgIHNwaXJhbER5bmFtaWNzU3RhZ2U6IHJhdy5zcGlyYWxEeW5hbWljc1N0YWdlLFxuICAgIHNwaXJhbEp1c3RpZmljYXRpb246IHJhdy5zcGlyYWxKdXN0aWZpY2F0aW9uLFxuICAgIHBoaWxvc29waGljYWxHZW5vbWU6IHtcbiAgICAgIGJlaW5nVnNCZWNvbWluZzogcmF3LnBoaWxvc29waGljYWxHZW5vbWUuYmVpbmdWc0JlY29taW5nIGFzIGFueSxcbiAgICAgIG9uZVZzTWFueTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUub25lVnNNYW55IGFzIGFueSxcbiAgICAgIG1pbmRWc01hdHRlcjogcmF3LnBoaWxvc29waGljYWxHZW5vbWUubWluZFZzTWF0dGVyIGFzIGFueSxcbiAgICAgIGZyZWVkb21Wc0RldGVybWluaXNtOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5mcmVlZG9tVnNEZXRlcm1pbmlzbSBhcyBhbnksXG4gICAgICB0cmFuc2NlbmRlbnRWc0ltbWFuZW50OiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS50cmFuc2NlbmRlbnRWc0ltbWFuZW50IGFzIGFueSxcbiAgICAgIHJlYWxpc21Wc0FudGlSZWFsaXNtOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5yZWFsaXNtVnNBbnRpUmVhbGlzbSBhcyBhbnksXG4gICAgICByZWFzb25Wc0V4cGVyaWVuY2U6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLnJlYXNvblZzRXhwZXJpZW5jZSBhcyBhbnksXG4gICAgICBhYnNvbHV0ZVZzUmVsYXRpdmU6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLmFic29sdXRlVnNSZWxhdGl2ZSBhcyBhbnksXG4gICAgfSxcbiAgICBzd2l0Y2hQb2ludHM6IHJhdy5zd2l0Y2hQb2ludHMgfHwgW10sXG4gICAgZG9tYWluU3RyZW5ndGhzOiByYXcuZG9tYWluU3RyZW5ndGhzLFxuICAgIGluZmx1ZW5jZXM6IHJhdy5pbmZsdWVuY2VzIHx8IFtdLFxuICAgIGNyaXRpcXVlczogcmF3LmNyaXRpcXVlcyB8fCBbXSxcbiAgICBjb21wcmVoZW5zaXZlQmlvZ3JhcGh5OiByYXcuY29tcHJlaGVuc2l2ZUJpb2dyYXBoeSxcbiAgICBpbnRlbGxlY3R1YWxKb3VybmV5OiByYXcuaW50ZWxsZWN0dWFsSm91cm5leSxcbiAgICBwcmltYXJ5RG9tYWluOiByYXcucHJpbWFyeURvbWFpbixcbiAgICBlcmE6IHJhdy5lcmEgYXMgYW55LFxuICAgIGVyYVBvc2l0aW9uOiByYXcuZXJhUG9zaXRpb24sXG4gICAgYmlydGhMb2NhdGlvbjogcmF3LmJpcnRoTG9jYXRpb24sXG4gICAgYWxsRG9tYWluczogcmF3LmFsbERvbWFpbnMsXG4gICAgaGlzdG9yaWNhbENvbnRleHQ6IHJhdy5oaXN0b3JpY2FsQ29udGV4dCxcbiAgICBzcGlyYWxUcmFuc2l0aW9uczogcmF3LnNwaXJhbFRyYW5zaXRpb25zXG4gIH0pKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBjb25uZWN0aW9ucyBiYXNlZCBvbiBpbmZsdWVuY2UgYW5kIGNyaXRpcXVlIHJlbGF0aW9uc2hpcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29ubmVjdGlvbnMocmF3RGF0YTogUmF3UGhpbG9zb3BoZXJEYXRhW10pOiBDb25uZWN0aW9uW10ge1xuICBjb25zdCBjb25uZWN0aW9uczogQ29ubmVjdGlvbltdID0gW107XG4gIFxuICByYXdEYXRhLmZvckVhY2gocGhpbG9zb3BoZXIgPT4ge1xuICAgIC8vIFByb2Nlc3MgaW5mbHVlbmNlc1xuICAgIGlmIChwaGlsb3NvcGhlci5pbmZsdWVuY2VNYXApIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBoaWxvc29waGVyLmluZmx1ZW5jZU1hcCkuZm9yRWFjaCgoW3NvdXJjZUlkLCBzdHJlbmd0aF0pID0+IHtcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgc291cmNlSWQsXG4gICAgICAgICAgdGFyZ2V0SWQ6IHBoaWxvc29waGVyLmlkLFxuICAgICAgICAgIHN0cmVuZ3RoLFxuICAgICAgICAgIHR5cGU6ICdpbmZsdWVuY2UnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgSW5mbHVlbmNlcyAke3BoaWxvc29waGVyLm5hbWV9J3MgcGhpbG9zb3BoaWNhbCBkZXZlbG9wbWVudGBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUHJvY2VzcyBjcml0aXF1ZXNcbiAgICBpZiAocGhpbG9zb3BoZXIuY3JpdGlxdWVNYXApIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHBoaWxvc29waGVyLmNyaXRpcXVlTWFwKS5mb3JFYWNoKChbdGFyZ2V0SWQsIHN0cmVuZ3RoXSkgPT4ge1xuICAgICAgICBjb25uZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2VJZDogcGhpbG9zb3BoZXIuaWQsXG4gICAgICAgICAgdGFyZ2V0SWQsXG4gICAgICAgICAgc3RyZW5ndGgsXG4gICAgICAgICAgdHlwZTogJ2NyaXRpcXVlJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7cGhpbG9zb3BoZXIubmFtZX0gY3JpdGlxdWVzIHRoaXMgcGhpbG9zb3BoaWNhbCBwb3NpdGlvbmBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBcbiAgcmV0dXJuIGNvbm5lY3Rpb25zO1xufVxuXG4vKipcbiAqIExvYWQgYW5kIHByb2Nlc3MgcGhpbG9zb3BoZXIgZGF0YSBmcm9tIEpTT04gZmlsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFBoaWxvc29waGVyRGF0YSgpOiBQcm9taXNlPHsgcGhpbG9zb3BoZXJzOiBQaGlsb3NvcGhlck5vZGVbXSwgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSB9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2RhdGEvcGhpbG9zb3BoZXJzLmpzb24nKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHBoaWxvc29waGVyIGRhdGE6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmF3RGF0YTogUmF3UGhpbG9zb3BoZXJEYXRhW10gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgY29uc3QgcGhpbG9zb3BoZXJzID0gdHJhbnNmb3JtUGhpbG9zb3BoZXJEYXRhKHJhd0RhdGEpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gZ2VuZXJhdGVDb25uZWN0aW9ucyhyYXdEYXRhKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7cGhpbG9zb3BoZXJzLmxlbmd0aH0gcGhpbG9zb3BoZXJzIGFuZCAke2Nvbm5lY3Rpb25zLmxlbmd0aH0gY29ubmVjdGlvbnNgKTtcbiAgICBcbiAgICByZXR1cm4geyBwaGlsb3NvcGhlcnMsIGNvbm5lY3Rpb25zIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwaGlsb3NvcGhlciBkYXRhOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJjYWxjdWxhdGVQb3NpdGlvbiIsInBoaWxvc29waGVyIiwiaW5kZXgiLCJ0b3RhbCIsImVyYVJhZGl1cyIsImVyYVBvc2l0aW9uIiwiZXJhQW5nbGVzIiwiTWF0aCIsIlBJIiwibWluQW5nbGUiLCJtYXhBbmdsZSIsImVyYSIsImFuZ2xlIiwiZ2Vub21lSGVpZ2h0IiwiZ2V0R2Vub21lSGVpZ2h0IiwicGhpbG9zb3BoaWNhbEdlbm9tZSIsInVuaXF1ZU9mZnNldCIsIm5hbWUiLCJjaGFyQ29kZUF0IiwieCIsImNvcyIsInoiLCJzaW4iLCJ5IiwiZ2Vub21lIiwidmFsdWVzIiwiZ2V0R2Vub21lVmFsdWUiLCJiZWluZ1ZzQmVjb21pbmciLCJvbmVWc01hbnkiLCJtaW5kVnNNYXR0ZXIiLCJmcmVlZG9tVnNEZXRlcm1pbmlzbSIsInRyYW5zY2VuZGVudFZzSW1tYW5lbnQiLCJyZWFsaXNtVnNBbnRpUmVhbGlzbSIsInJlYXNvblZzRXhwZXJpZW5jZSIsImFic29sdXRlVnNSZWxhdGl2ZSIsInJlZHVjZSIsInN1bSIsInZhbCIsImxlbmd0aCIsInBvc2l0aW9uIiwidmFsdWVNYXAiLCJ0cmFuc2Zvcm1QaGlsb3NvcGhlckRhdGEiLCJyYXdEYXRhIiwibWFwIiwicmF3IiwiaWQiLCJiaXJ0aFllYXIiLCJkZWF0aFllYXIiLCJzcGlyYWxEeW5hbWljc1N0YWdlIiwic3BpcmFsSnVzdGlmaWNhdGlvbiIsInN3aXRjaFBvaW50cyIsImRvbWFpblN0cmVuZ3RocyIsImluZmx1ZW5jZXMiLCJjcml0aXF1ZXMiLCJjb21wcmVoZW5zaXZlQmlvZ3JhcGh5IiwiaW50ZWxsZWN0dWFsSm91cm5leSIsInByaW1hcnlEb21haW4iLCJiaXJ0aExvY2F0aW9uIiwiYWxsRG9tYWlucyIsImhpc3RvcmljYWxDb250ZXh0Iiwic3BpcmFsVHJhbnNpdGlvbnMiLCJnZW5lcmF0ZUNvbm5lY3Rpb25zIiwiY29ubmVjdGlvbnMiLCJmb3JFYWNoIiwiaW5mbHVlbmNlTWFwIiwiT2JqZWN0IiwiZW50cmllcyIsInNvdXJjZUlkIiwic3RyZW5ndGgiLCJwdXNoIiwidGFyZ2V0SWQiLCJ0eXBlIiwiZGVzY3JpcHRpb24iLCJjcml0aXF1ZU1hcCIsImxvYWRQaGlsb3NvcGhlckRhdGEiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJqc29uIiwicGhpbG9zb3BoZXJzIiwiY29uc29sZSIsImxvZyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/data/philosopher-loader.ts\n"));

/***/ })

}]);