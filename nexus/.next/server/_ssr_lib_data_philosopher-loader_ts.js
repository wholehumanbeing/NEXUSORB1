"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_data_philosopher-loader_ts";
exports.ids = ["_ssr_lib_data_philosopher-loader_ts"];
exports.modules = {

/***/ "(ssr)/./lib/data/philosopher-loader.ts":
/*!****************************************!*\
  !*** ./lib/data/philosopher-loader.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateConnections: () => (/* binding */ generateConnections),\n/* harmony export */   loadPhilosopherData: () => (/* binding */ loadPhilosopherData),\n/* harmony export */   transformPhilosopherData: () => (/* binding */ transformPhilosopherData)\n/* harmony export */ });\n/**\n * Generates 3D position based on philosopher's characteristics\n */ function calculatePosition(philosopher, index, total) {\n    // Use era and primary characteristics to position in 3D space\n    const eraRadius = philosopher.eraPosition * 8; // Scale era position to radius\n    // Map era to angle ranges\n    const eraAngles = {\n        \"Ancient\": [\n            0,\n            Math.PI / 2\n        ],\n        \"Medieval\": [\n            Math.PI / 2,\n            Math.PI\n        ],\n        \"Modern\": [\n            Math.PI,\n            3 * Math.PI / 2\n        ],\n        \"Contemporary\": [\n            3 * Math.PI / 2,\n            2 * Math.PI\n        ]\n    };\n    const [minAngle, maxAngle] = eraAngles[philosopher.era] || [\n        0,\n        2 * Math.PI\n    ];\n    const angle = minAngle + philosopher.eraPosition * (maxAngle - minAngle);\n    // Use genome characteristics for height positioning\n    const genomeHeight = getGenomeHeight(philosopher.philosophicalGenome);\n    // Add some randomness based on philosopher's unique characteristics\n    const uniqueOffset = philosopher.name.charCodeAt(0) % 100 / 100;\n    const x = eraRadius * Math.cos(angle) + uniqueOffset;\n    const z = eraRadius * Math.sin(angle) + uniqueOffset;\n    const y = genomeHeight * 4 - 2; // Range from -2 to 2\n    return [\n        x,\n        y,\n        z\n    ];\n}\n/**\n * Calculate height based on philosophical genome characteristics\n */ function getGenomeHeight(genome) {\n    // Map genome positions to numerical values for height calculation\n    const values = [\n        getGenomeValue(genome.beingVsBecoming),\n        getGenomeValue(genome.oneVsMany),\n        getGenomeValue(genome.mindVsMatter),\n        getGenomeValue(genome.freedomVsDeterminism),\n        getGenomeValue(genome.transcendentVsImmanent),\n        getGenomeValue(genome.realismVsAntiRealism),\n        getGenomeValue(genome.reasonVsExperience),\n        getGenomeValue(genome.absoluteVsRelative)\n    ];\n    return values.reduce((sum, val)=>sum + val, 0) / values.length;\n}\nfunction getGenomeValue(position) {\n    const valueMap = {\n        \"Being\": 0.2,\n        \"Becoming\": 0.8,\n        \"One\": 0.2,\n        \"Many\": 0.8,\n        \"Mind\": 0.2,\n        \"Matter\": 0.8,\n        \"Freedom\": 0.8,\n        \"Determinism\": 0.2,\n        \"Transcendent\": 0.8,\n        \"Immanent\": 0.2,\n        \"Realist\": 0.2,\n        \"Anti-realist\": 0.8,\n        \"Reason\": 0.2,\n        \"Experience\": 0.8,\n        \"Absolute\": 0.2,\n        \"Relative\": 0.8,\n        \"Both\": 0.5,\n        \"Dualist\": 0.5,\n        \"Synthesis\": 0.5\n    };\n    return valueMap[position] || 0.5;\n}\n/**\n * Transform raw philosopher data into PhilosopherNode format\n */ function transformPhilosopherData(rawData) {\n    return rawData.map((raw, index)=>({\n            id: raw.id,\n            name: raw.name,\n            birthYear: raw.birthYear,\n            deathYear: raw.deathYear,\n            position: calculatePosition(raw, index, rawData.length),\n            spiralDynamicsStage: raw.spiralDynamicsStage,\n            spiralJustification: raw.spiralJustification,\n            philosophicalGenome: {\n                beingVsBecoming: raw.philosophicalGenome.beingVsBecoming,\n                oneVsMany: raw.philosophicalGenome.oneVsMany,\n                mindVsMatter: raw.philosophicalGenome.mindVsMatter,\n                freedomVsDeterminism: raw.philosophicalGenome.freedomVsDeterminism,\n                transcendentVsImmanent: raw.philosophicalGenome.transcendentVsImmanent,\n                realismVsAntiRealism: raw.philosophicalGenome.realismVsAntiRealism,\n                reasonVsExperience: raw.philosophicalGenome.reasonVsExperience,\n                absoluteVsRelative: raw.philosophicalGenome.absoluteVsRelative\n            },\n            switchPoints: raw.switchPoints || [],\n            domainStrengths: raw.domainStrengths,\n            influences: raw.influences || [],\n            critiques: raw.critiques || [],\n            comprehensiveBiography: raw.comprehensiveBiography,\n            intellectualJourney: raw.intellectualJourney,\n            primaryDomain: raw.primaryDomain,\n            era: raw.era,\n            eraPosition: raw.eraPosition,\n            birthLocation: raw.birthLocation,\n            allDomains: raw.allDomains,\n            historicalContext: raw.historicalContext,\n            spiralTransitions: raw.spiralTransitions\n        }));\n}\n/**\n * Generate connections based on influence and critique relationships\n */ function generateConnections(rawData) {\n    const connections = [];\n    rawData.forEach((philosopher)=>{\n        // Process influences\n        if (philosopher.influenceMap) {\n            Object.entries(philosopher.influenceMap).forEach(([sourceId, strength])=>{\n                connections.push({\n                    sourceId,\n                    targetId: philosopher.id,\n                    strength,\n                    type: \"influence\",\n                    description: `Influences ${philosopher.name}'s philosophical development`\n                });\n            });\n        }\n        // Process critiques\n        if (philosopher.critiqueMap) {\n            Object.entries(philosopher.critiqueMap).forEach(([targetId, strength])=>{\n                connections.push({\n                    sourceId: philosopher.id,\n                    targetId,\n                    strength,\n                    type: \"critique\",\n                    description: `${philosopher.name} critiques this philosophical position`\n                });\n            });\n        }\n    });\n    return connections;\n}\n/**\n * Load and process philosopher data from database API\n */ async function loadPhilosopherData() {\n    try {\n        const response = await fetch(\"/api/philosophers\");\n        if (!response.ok) {\n            throw new Error(`Failed to load philosopher data: ${response.statusText}`);\n        }\n        const rawData = await response.json();\n        const philosophers = transformPhilosopherData(rawData);\n        const connections = generateConnections(rawData);\n        console.log(`Loaded ${philosophers.length} philosophers and ${connections.length} connections`);\n        return {\n            philosophers,\n            connections\n        };\n    } catch (error) {\n        console.error(\"Error loading philosopher data:\", error);\n        // Fallback to JSON file if API fails\n        try {\n            const fallbackResponse = await fetch(\"/data/philosophers.json\");\n            if (fallbackResponse.ok) {\n                const fallbackData = await fallbackResponse.json();\n                const philosophers = transformPhilosopherData(fallbackData);\n                const connections = generateConnections(fallbackData);\n                console.log(\"Using fallback JSON data:\", philosophers.length, \"philosophers\");\n                return {\n                    philosophers,\n                    connections\n                };\n            }\n        } catch (fallbackError) {\n            console.error(\"Fallback also failed:\", fallbackError);\n        }\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRSxPQUFPc0IsT0FBTztRQUNkRixRQUFRRSxLQUFLLENBQUMsbUNBQW1DQTtRQUNqRCxxQ0FBcUM7UUFDckMsSUFBSTtZQUNGLE1BQU1DLG1CQUFtQixNQUFNVCxNQUFNO1lBQ3JDLElBQUlTLGlCQUFpQlIsRUFBRSxFQUFFO2dCQUN2QixNQUFNUyxlQUFxQyxNQUFNRCxpQkFBaUJMLElBQUk7Z0JBQ3RFLE1BQU1DLGVBQWV4Qyx5QkFBeUI2QztnQkFDOUMsTUFBTXhCLGNBQWNELG9CQUFvQnlCO2dCQUN4Q0osUUFBUUMsR0FBRyxDQUFDLDZCQUE2QkYsYUFBYTNDLE1BQU0sRUFBRTtnQkFDOUQsT0FBTztvQkFBRTJDO29CQUFjbkI7Z0JBQVk7WUFDckM7UUFDRixFQUFFLE9BQU95QixlQUFlO1lBQ3RCTCxRQUFRRSxLQUFLLENBQUMseUJBQXlCRztRQUN6QztRQUNBLE1BQU1IO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BoaWxvc29waGljYWwtbmV4dXMvLi9saWIvZGF0YS9waGlsb3NvcGhlci1sb2FkZXIudHM/OTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaGlsb3NvcGhlck5vZGUsIENvbm5lY3Rpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmF3UGhpbG9zb3BoZXJEYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBiaXJ0aFllYXI6IG51bWJlcjtcbiAgZGVhdGhZZWFyOiBudW1iZXI7XG4gIGJpcnRoTG9jYXRpb24/OiB7XG4gICAgY2l0eTogc3RyaW5nO1xuICAgIHJlZ2lvbjogc3RyaW5nO1xuICAgIG1vZGVybkNvdW50cnk6IHN0cmluZztcbiAgICBjb29yZGluYXRlczogW251bWJlciwgbnVtYmVyXTtcbiAgfTtcbiAgcHJpbWFyeURvbWFpbjogc3RyaW5nO1xuICBhbGxEb21haW5zPzogc3RyaW5nW107XG4gIGRvbWFpblN0cmVuZ3RoczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgZXJhOiBzdHJpbmc7XG4gIGVyYVBvc2l0aW9uOiBudW1iZXI7XG4gIHNwaXJhbER5bmFtaWNzU3RhZ2U6IHN0cmluZztcbiAgc3BpcmFsSnVzdGlmaWNhdGlvbjogc3RyaW5nO1xuICBzcGlyYWxUcmFuc2l0aW9ucz86IHN0cmluZ1tdO1xuICBwaGlsb3NvcGhpY2FsR2Vub21lOiB7XG4gICAgYmVpbmdWc0JlY29taW5nOiBzdHJpbmc7XG4gICAgb25lVnNNYW55OiBzdHJpbmc7XG4gICAgbWluZFZzTWF0dGVyOiBzdHJpbmc7XG4gICAgZnJlZWRvbVZzRGV0ZXJtaW5pc206IHN0cmluZztcbiAgICB0cmFuc2NlbmRlbnRWc0ltbWFuZW50OiBzdHJpbmc7XG4gICAgcmVhbGlzbVZzQW50aVJlYWxpc206IHN0cmluZztcbiAgICByZWFzb25Wc0V4cGVyaWVuY2U6IHN0cmluZztcbiAgICBhYnNvbHV0ZVZzUmVsYXRpdmU6IHN0cmluZztcbiAgICBnZW5vbWVKdXN0aWZpY2F0aW9ucz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIH07XG4gIHN3aXRjaFBvaW50cz86IEFycmF5PHtcbiAgICBxdWVzdGlvbjogc3RyaW5nO1xuICAgIHBvc2l0aW9uOiBzdHJpbmc7XG4gICAgYXJndW1lbnQ6IHN0cmluZztcbiAgICBkb21haW5DYXNjYWRlcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIH0+O1xuICBjb21wcmVoZW5zaXZlQmlvZ3JhcGh5OiBzdHJpbmc7XG4gIGludGVsbGVjdHVhbEpvdXJuZXk6IHN0cmluZztcbiAgaGlzdG9yaWNhbENvbnRleHQ/OiBzdHJpbmc7XG4gIGluZmx1ZW5jZXM/OiBzdHJpbmdbXTtcbiAgY3JpdGlxdWVzPzogc3RyaW5nW107XG4gIGluZmx1ZW5jZU1hcD86IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGNyaXRpcXVlTWFwPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgM0QgcG9zaXRpb24gYmFzZWQgb24gcGhpbG9zb3BoZXIncyBjaGFyYWN0ZXJpc3RpY3NcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb24ocGhpbG9zb3BoZXI6IFJhd1BoaWxvc29waGVyRGF0YSwgaW5kZXg6IG51bWJlciwgdG90YWw6IG51bWJlcik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIC8vIFVzZSBlcmEgYW5kIHByaW1hcnkgY2hhcmFjdGVyaXN0aWNzIHRvIHBvc2l0aW9uIGluIDNEIHNwYWNlXG4gIGNvbnN0IGVyYVJhZGl1cyA9IHBoaWxvc29waGVyLmVyYVBvc2l0aW9uICogODsgLy8gU2NhbGUgZXJhIHBvc2l0aW9uIHRvIHJhZGl1c1xuICBcbiAgLy8gTWFwIGVyYSB0byBhbmdsZSByYW5nZXNcbiAgY29uc3QgZXJhQW5nbGVzOiBSZWNvcmQ8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiA9IHtcbiAgICAnQW5jaWVudCc6IFswLCBNYXRoLlBJIC8gMl0sXG4gICAgJ01lZGlldmFsJzogW01hdGguUEkgLyAyLCBNYXRoLlBJXSxcbiAgICAnTW9kZXJuJzogW01hdGguUEksIDMgKiBNYXRoLlBJIC8gMl0sXG4gICAgJ0NvbnRlbXBvcmFyeSc6IFszICogTWF0aC5QSSAvIDIsIDIgKiBNYXRoLlBJXVxuICB9O1xuICBcbiAgY29uc3QgW21pbkFuZ2xlLCBtYXhBbmdsZV0gPSBlcmFBbmdsZXNbcGhpbG9zb3BoZXIuZXJhXSB8fCBbMCwgMiAqIE1hdGguUEldO1xuICBjb25zdCBhbmdsZSA9IG1pbkFuZ2xlICsgKHBoaWxvc29waGVyLmVyYVBvc2l0aW9uICogKG1heEFuZ2xlIC0gbWluQW5nbGUpKTtcbiAgXG4gIC8vIFVzZSBnZW5vbWUgY2hhcmFjdGVyaXN0aWNzIGZvciBoZWlnaHQgcG9zaXRpb25pbmdcbiAgY29uc3QgZ2Vub21lSGVpZ2h0ID0gZ2V0R2Vub21lSGVpZ2h0KHBoaWxvc29waGVyLnBoaWxvc29waGljYWxHZW5vbWUpO1xuICBcbiAgLy8gQWRkIHNvbWUgcmFuZG9tbmVzcyBiYXNlZCBvbiBwaGlsb3NvcGhlcidzIHVuaXF1ZSBjaGFyYWN0ZXJpc3RpY3NcbiAgY29uc3QgdW5pcXVlT2Zmc2V0ID0gKHBoaWxvc29waGVyLm5hbWUuY2hhckNvZGVBdCgwKSAlIDEwMCkgLyAxMDA7XG4gIFxuICBjb25zdCB4ID0gZXJhUmFkaXVzICogTWF0aC5jb3MoYW5nbGUpICsgdW5pcXVlT2Zmc2V0O1xuICBjb25zdCB6ID0gZXJhUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpICsgdW5pcXVlT2Zmc2V0O1xuICBjb25zdCB5ID0gZ2Vub21lSGVpZ2h0ICogNCAtIDI7IC8vIFJhbmdlIGZyb20gLTIgdG8gMlxuICBcbiAgcmV0dXJuIFt4LCB5LCB6XTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgaGVpZ2h0IGJhc2VkIG9uIHBoaWxvc29waGljYWwgZ2Vub21lIGNoYXJhY3RlcmlzdGljc1xuICovXG5mdW5jdGlvbiBnZXRHZW5vbWVIZWlnaHQoZ2Vub21lOiBSYXdQaGlsb3NvcGhlckRhdGFbJ3BoaWxvc29waGljYWxHZW5vbWUnXSk6IG51bWJlciB7XG4gIC8vIE1hcCBnZW5vbWUgcG9zaXRpb25zIHRvIG51bWVyaWNhbCB2YWx1ZXMgZm9yIGhlaWdodCBjYWxjdWxhdGlvblxuICBjb25zdCB2YWx1ZXMgPSBbXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLmJlaW5nVnNCZWNvbWluZyksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLm9uZVZzTWFueSksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLm1pbmRWc01hdHRlciksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLmZyZWVkb21Wc0RldGVybWluaXNtKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUudHJhbnNjZW5kZW50VnNJbW1hbmVudCksXG4gICAgZ2V0R2Vub21lVmFsdWUoZ2Vub21lLnJlYWxpc21Wc0FudGlSZWFsaXNtKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUucmVhc29uVnNFeHBlcmllbmNlKSxcbiAgICBnZXRHZW5vbWVWYWx1ZShnZW5vbWUuYWJzb2x1dGVWc1JlbGF0aXZlKVxuICBdO1xuICBcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwsIDApIC8gdmFsdWVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0R2Vub21lVmFsdWUocG9zaXRpb246IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHZhbHVlTWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICdCZWluZyc6IDAuMixcbiAgICAnQmVjb21pbmcnOiAwLjgsXG4gICAgJ09uZSc6IDAuMixcbiAgICAnTWFueSc6IDAuOCxcbiAgICAnTWluZCc6IDAuMixcbiAgICAnTWF0dGVyJzogMC44LFxuICAgICdGcmVlZG9tJzogMC44LFxuICAgICdEZXRlcm1pbmlzbSc6IDAuMixcbiAgICAnVHJhbnNjZW5kZW50JzogMC44LFxuICAgICdJbW1hbmVudCc6IDAuMixcbiAgICAnUmVhbGlzdCc6IDAuMixcbiAgICAnQW50aS1yZWFsaXN0JzogMC44LFxuICAgICdSZWFzb24nOiAwLjIsXG4gICAgJ0V4cGVyaWVuY2UnOiAwLjgsXG4gICAgJ0Fic29sdXRlJzogMC4yLFxuICAgICdSZWxhdGl2ZSc6IDAuOCxcbiAgICAnQm90aCc6IDAuNSxcbiAgICAnRHVhbGlzdCc6IDAuNSxcbiAgICAnU3ludGhlc2lzJzogMC41XG4gIH07XG4gIFxuICByZXR1cm4gdmFsdWVNYXBbcG9zaXRpb25dIHx8IDAuNTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gcmF3IHBoaWxvc29waGVyIGRhdGEgaW50byBQaGlsb3NvcGhlck5vZGUgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1QaGlsb3NvcGhlckRhdGEocmF3RGF0YTogUmF3UGhpbG9zb3BoZXJEYXRhW10pOiBQaGlsb3NvcGhlck5vZGVbXSB7XG4gIHJldHVybiByYXdEYXRhLm1hcCgocmF3LCBpbmRleCkgPT4gKHtcbiAgICBpZDogcmF3LmlkLFxuICAgIG5hbWU6IHJhdy5uYW1lLFxuICAgIGJpcnRoWWVhcjogcmF3LmJpcnRoWWVhcixcbiAgICBkZWF0aFllYXI6IHJhdy5kZWF0aFllYXIsXG4gICAgcG9zaXRpb246IGNhbGN1bGF0ZVBvc2l0aW9uKHJhdywgaW5kZXgsIHJhd0RhdGEubGVuZ3RoKSxcbiAgICBzcGlyYWxEeW5hbWljc1N0YWdlOiByYXcuc3BpcmFsRHluYW1pY3NTdGFnZSxcbiAgICBzcGlyYWxKdXN0aWZpY2F0aW9uOiByYXcuc3BpcmFsSnVzdGlmaWNhdGlvbixcbiAgICBwaGlsb3NvcGhpY2FsR2Vub21lOiB7XG4gICAgICBiZWluZ1ZzQmVjb21pbmc6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLmJlaW5nVnNCZWNvbWluZyBhcyBhbnksXG4gICAgICBvbmVWc01hbnk6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLm9uZVZzTWFueSBhcyBhbnksXG4gICAgICBtaW5kVnNNYXR0ZXI6IHJhdy5waGlsb3NvcGhpY2FsR2Vub21lLm1pbmRWc01hdHRlciBhcyBhbnksXG4gICAgICBmcmVlZG9tVnNEZXRlcm1pbmlzbTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUuZnJlZWRvbVZzRGV0ZXJtaW5pc20gYXMgYW55LFxuICAgICAgdHJhbnNjZW5kZW50VnNJbW1hbmVudDogcmF3LnBoaWxvc29waGljYWxHZW5vbWUudHJhbnNjZW5kZW50VnNJbW1hbmVudCBhcyBhbnksXG4gICAgICByZWFsaXNtVnNBbnRpUmVhbGlzbTogcmF3LnBoaWxvc29waGljYWxHZW5vbWUucmVhbGlzbVZzQW50aVJlYWxpc20gYXMgYW55LFxuICAgICAgcmVhc29uVnNFeHBlcmllbmNlOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5yZWFzb25Wc0V4cGVyaWVuY2UgYXMgYW55LFxuICAgICAgYWJzb2x1dGVWc1JlbGF0aXZlOiByYXcucGhpbG9zb3BoaWNhbEdlbm9tZS5hYnNvbHV0ZVZzUmVsYXRpdmUgYXMgYW55LFxuICAgIH0sXG4gICAgc3dpdGNoUG9pbnRzOiByYXcuc3dpdGNoUG9pbnRzIHx8IFtdLFxuICAgIGRvbWFpblN0cmVuZ3RoczogcmF3LmRvbWFpblN0cmVuZ3RocyxcbiAgICBpbmZsdWVuY2VzOiByYXcuaW5mbHVlbmNlcyB8fCBbXSxcbiAgICBjcml0aXF1ZXM6IHJhdy5jcml0aXF1ZXMgfHwgW10sXG4gICAgY29tcHJlaGVuc2l2ZUJpb2dyYXBoeTogcmF3LmNvbXByZWhlbnNpdmVCaW9ncmFwaHksXG4gICAgaW50ZWxsZWN0dWFsSm91cm5leTogcmF3LmludGVsbGVjdHVhbEpvdXJuZXksXG4gICAgcHJpbWFyeURvbWFpbjogcmF3LnByaW1hcnlEb21haW4sXG4gICAgZXJhOiByYXcuZXJhIGFzIGFueSxcbiAgICBlcmFQb3NpdGlvbjogcmF3LmVyYVBvc2l0aW9uLFxuICAgIGJpcnRoTG9jYXRpb246IHJhdy5iaXJ0aExvY2F0aW9uLFxuICAgIGFsbERvbWFpbnM6IHJhdy5hbGxEb21haW5zLFxuICAgIGhpc3RvcmljYWxDb250ZXh0OiByYXcuaGlzdG9yaWNhbENvbnRleHQsXG4gICAgc3BpcmFsVHJhbnNpdGlvbnM6IHJhdy5zcGlyYWxUcmFuc2l0aW9uc1xuICB9KSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY29ubmVjdGlvbnMgYmFzZWQgb24gaW5mbHVlbmNlIGFuZCBjcml0aXF1ZSByZWxhdGlvbnNoaXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNvbm5lY3Rpb25zKHJhd0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdKTogQ29ubmVjdGlvbltdIHtcbiAgY29uc3QgY29ubmVjdGlvbnM6IENvbm5lY3Rpb25bXSA9IFtdO1xuICBcbiAgcmF3RGF0YS5mb3JFYWNoKHBoaWxvc29waGVyID0+IHtcbiAgICAvLyBQcm9jZXNzIGluZmx1ZW5jZXNcbiAgICBpZiAocGhpbG9zb3BoZXIuaW5mbHVlbmNlTWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhwaGlsb3NvcGhlci5pbmZsdWVuY2VNYXApLmZvckVhY2goKFtzb3VyY2VJZCwgc3RyZW5ndGhdKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb25zLnB1c2goe1xuICAgICAgICAgIHNvdXJjZUlkLFxuICAgICAgICAgIHRhcmdldElkOiBwaGlsb3NvcGhlci5pZCxcbiAgICAgICAgICBzdHJlbmd0aCxcbiAgICAgICAgICB0eXBlOiAnaW5mbHVlbmNlJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEluZmx1ZW5jZXMgJHtwaGlsb3NvcGhlci5uYW1lfSdzIHBoaWxvc29waGljYWwgZGV2ZWxvcG1lbnRgXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFByb2Nlc3MgY3JpdGlxdWVzXG4gICAgaWYgKHBoaWxvc29waGVyLmNyaXRpcXVlTWFwKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhwaGlsb3NvcGhlci5jcml0aXF1ZU1hcCkuZm9yRWFjaCgoW3RhcmdldElkLCBzdHJlbmd0aF0pID0+IHtcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgc291cmNlSWQ6IHBoaWxvc29waGVyLmlkLFxuICAgICAgICAgIHRhcmdldElkLFxuICAgICAgICAgIHN0cmVuZ3RoLFxuICAgICAgICAgIHR5cGU6ICdjcml0aXF1ZScsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGAke3BoaWxvc29waGVyLm5hbWV9IGNyaXRpcXVlcyB0aGlzIHBoaWxvc29waGljYWwgcG9zaXRpb25gXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgXG4gIHJldHVybiBjb25uZWN0aW9ucztcbn1cblxuLyoqXG4gKiBMb2FkIGFuZCBwcm9jZXNzIHBoaWxvc29waGVyIGRhdGEgZnJvbSBkYXRhYmFzZSBBUElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQaGlsb3NvcGhlckRhdGEoKTogUHJvbWlzZTx7IHBoaWxvc29waGVyczogUGhpbG9zb3BoZXJOb2RlW10sIGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uW10gfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcGhpbG9zb3BoZXJzJyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBwaGlsb3NvcGhlciBkYXRhOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJhd0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGNvbnN0IHBoaWxvc29waGVycyA9IHRyYW5zZm9ybVBoaWxvc29waGVyRGF0YShyYXdEYXRhKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IGdlbmVyYXRlQ29ubmVjdGlvbnMocmF3RGF0YSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYExvYWRlZCAke3BoaWxvc29waGVycy5sZW5ndGh9IHBoaWxvc29waGVycyBhbmQgJHtjb25uZWN0aW9ucy5sZW5ndGh9IGNvbm5lY3Rpb25zYCk7XG4gICAgXG4gICAgcmV0dXJuIHsgcGhpbG9zb3BoZXJzLCBjb25uZWN0aW9ucyB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcGhpbG9zb3BoZXIgZGF0YTonLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2sgdG8gSlNPTiBmaWxlIGlmIEFQSSBmYWlsc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9kYXRhL3BoaWxvc29waGVycy5qc29uJyk7XG4gICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBmYWxsYmFja0RhdGE6IFJhd1BoaWxvc29waGVyRGF0YVtdID0gYXdhaXQgZmFsbGJhY2tSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHBoaWxvc29waGVycyA9IHRyYW5zZm9ybVBoaWxvc29waGVyRGF0YShmYWxsYmFja0RhdGEpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGdlbmVyYXRlQ29ubmVjdGlvbnMoZmFsbGJhY2tEYXRhKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGZhbGxiYWNrIEpTT04gZGF0YTonLCBwaGlsb3NvcGhlcnMubGVuZ3RoLCAncGhpbG9zb3BoZXJzJyk7XG4gICAgICAgIHJldHVybiB7IHBoaWxvc29waGVycywgY29ubmVjdGlvbnMgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWxsYmFjayBhbHNvIGZhaWxlZDonLCBmYWxsYmFja0Vycm9yKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0iXSwibmFtZXMiOlsiY2FsY3VsYXRlUG9zaXRpb24iLCJwaGlsb3NvcGhlciIsImluZGV4IiwidG90YWwiLCJlcmFSYWRpdXMiLCJlcmFQb3NpdGlvbiIsImVyYUFuZ2xlcyIsIk1hdGgiLCJQSSIsIm1pbkFuZ2xlIiwibWF4QW5nbGUiLCJlcmEiLCJhbmdsZSIsImdlbm9tZUhlaWdodCIsImdldEdlbm9tZUhlaWdodCIsInBoaWxvc29waGljYWxHZW5vbWUiLCJ1bmlxdWVPZmZzZXQiLCJuYW1lIiwiY2hhckNvZGVBdCIsIngiLCJjb3MiLCJ6Iiwic2luIiwieSIsImdlbm9tZSIsInZhbHVlcyIsImdldEdlbm9tZVZhbHVlIiwiYmVpbmdWc0JlY29taW5nIiwib25lVnNNYW55IiwibWluZFZzTWF0dGVyIiwiZnJlZWRvbVZzRGV0ZXJtaW5pc20iLCJ0cmFuc2NlbmRlbnRWc0ltbWFuZW50IiwicmVhbGlzbVZzQW50aVJlYWxpc20iLCJyZWFzb25Wc0V4cGVyaWVuY2UiLCJhYnNvbHV0ZVZzUmVsYXRpdmUiLCJyZWR1Y2UiLCJzdW0iLCJ2YWwiLCJsZW5ndGgiLCJwb3NpdGlvbiIsInZhbHVlTWFwIiwidHJhbnNmb3JtUGhpbG9zb3BoZXJEYXRhIiwicmF3RGF0YSIsIm1hcCIsInJhdyIsImlkIiwiYmlydGhZZWFyIiwiZGVhdGhZZWFyIiwic3BpcmFsRHluYW1pY3NTdGFnZSIsInNwaXJhbEp1c3RpZmljYXRpb24iLCJzd2l0Y2hQb2ludHMiLCJkb21haW5TdHJlbmd0aHMiLCJpbmZsdWVuY2VzIiwiY3JpdGlxdWVzIiwiY29tcHJlaGVuc2l2ZUJpb2dyYXBoeSIsImludGVsbGVjdHVhbEpvdXJuZXkiLCJwcmltYXJ5RG9tYWluIiwiYmlydGhMb2NhdGlvbiIsImFsbERvbWFpbnMiLCJoaXN0b3JpY2FsQ29udGV4dCIsInNwaXJhbFRyYW5zaXRpb25zIiwiZ2VuZXJhdGVDb25uZWN0aW9ucyIsImNvbm5lY3Rpb25zIiwiZm9yRWFjaCIsImluZmx1ZW5jZU1hcCIsIk9iamVjdCIsImVudHJpZXMiLCJzb3VyY2VJZCIsInN0cmVuZ3RoIiwicHVzaCIsInRhcmdldElkIiwidHlwZSIsImRlc2NyaXB0aW9uIiwiY3JpdGlxdWVNYXAiLCJsb2FkUGhpbG9zb3BoZXJEYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwianNvbiIsInBoaWxvc29waGVycyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImZhbGxiYWNrUmVzcG9uc2UiLCJmYWxsYmFja0RhdGEiLCJmYWxsYmFja0Vycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./lib/data/philosopher-loader.ts\n");

/***/ })

};
;