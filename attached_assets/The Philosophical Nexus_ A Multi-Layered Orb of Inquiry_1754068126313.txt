Prompt for AI Systems Architect
Objective: Create a master implementation plan to completely refactor and rebuild the 'Philosophical Nexus' application.
Your Persona: You are an expert systems architect and senior full-stack engineer with deep, hands-on experience in Next.js, Three.js, data visualization, GraphQL, and graph databases. You are tasked with creating a definitive, multi-phase engineering roadmap to rescue a promising but critically flawed project.
Context: The 'Philosophical Nexus' project has a profound vision but is crippled by foundational architectural failures, a complete disconnect from its core data, and a massive gap between its current state and its goals. Your task is to provide a detailed, step-by-step plan to fix every identified issue and build a scalable, performant, and feature-complete application. You have full access to the existing codebase and the project's vision documents.
The Mandate: Your plan must be meticulous, actionable, and address every point outlined below. The end deliverable is not the code itself, but a master engineering plan that another development team can follow precisely.
________________
Master Implementation Plan: The Philosophical Nexus Refactoring
Your plan must be structured into the following distinct phases. For each phase, describe the goals, key actions, technology choices, and architectural decisions required.
Phase 0: Triage, Stabilization, and Foundation
This phase is about stopping the bleeding and establishing a stable foundation for all future work.
1. Correct the Core Architectural Blunder:
   * Action: Modify next.config.ts. Immediately remove the output: 'export' line.
   * Justification: The project's vision for a dynamic, multi-layered application with user accounts and database interaction (Layers 2 and 3) is technically impossible with a static site export. This is the single most critical blocker and must be the first action taken. The application must be configured for server-side rendering (SSR) or API routes to support a backend.
2. Radical Code Simplification:
   * Action: Perform a surgical removal of all redundant and conflicting code.
      * Delete the entire PhilosophyOrbSpiral.tsx component.
      * Delete the ControlPanel.tsx component.
      * Delete the placeholder data files (app/data/ancientPhilosophers.ts, app/data/philosophers.ts, etc.). They are a distraction from the real data.
   * Goal: Establish Globe.tsx as the single, undisputed source of truth for the 3D visualization. Eliminate all conflicting renderers, state, and logic.
3. Implement a Scalable State Management Solution:
   * Action: Integrate Zustand as the application's state management library.
   * Justification: The existing "god component" and the proposed React Context solution are inadequate for this application's complexity. Zustand allows for decoupled, atomic state management where components subscribe only to the data slices they need, preventing the performance-killing re-renders inherent to Context.
   * Task: Create initial state "stores" for UI state (e.g., isSidebarOpen, activeFilters), visualization state (e.g., cameraPosition, selectedNode), and user state (e.g., currentUserProfile).
4. Dependency & Security Review:
   * Action: Analyze the package.json. Pin major dependencies like Next.js and React to the latest stable, "battle-tested" minor versions (e.g., the latest Next.js 14 release) instead of bleeding-edge major versions (15+).
   * Goal: Reduce the risk of encountering instability or undocumented bugs from new, unproven releases.
________________
Phase 1: Backend Architecture & The Neo4j Data Pipeline
This phase focuses on building the data backbone of the entire application, driven by the rich JSON data.
1. Neo4j Aura Backend Scaffolding:
   * Action: Architect the backend using Neo4j Aura as the primary graph database.
   * Task: Design a comprehensive graph schema to model the entirety of the project's intellectual domain. This schema must account for every JSON file in the DATA/ directory. Your design should include, but not be limited to, the following:
      * Nodes: Philosopher, Work, Concept, SchoolOfThought, HistoricalEra, Domain (Metaphysics, Ethics, etc.).
      * Properties: Populate nodes with all relevant data from the JSONs (e.g., a Philosopher node must have properties for philosophicalGenome, spiralDynamicsStage, domainStrengths, comprehensiveBiography, etc.).
      * Relationships: Define the relationships that form the "Fractillion Trace." Examples: INFLUENCED_BY, INFLUENCED, WROTE, CRITIQUED, AGREED_WITH, BUILT_UPON, BELONGS_TO_SCHOOL, KEY_FIGURE_IN_ERA. Model the "Switch Points" as specific types of relationships or properties on relationships.
2. Data Ingestion Pipeline:
   * Action: Create a one-time, robust data ingestion script (e.g., using Node.js or Python).
   * Task: This script must parse every single JSON file in the DATA/ directory and populate the Neo4j Aura database according to the schema you designed. It must correctly create all nodes, define their properties, and establish the intricate web of relationships between them.
3. Next.js API Layer:
   * Action: Build out a set of API routes within the Next.js application to serve as the interface to the Neo4j database.
   * Task: Create API endpoints for all required data queries. For example:
      * GET /api/philosophers/[id]: Fetch a single philosopher's complete data.
      * GET /api/graph/full: Fetch the entire graph of philosophers and their primary influence connections for the initial Layer 1 visualization.
      * POST /api/graph/trace: An endpoint that accepts two philosopher IDs and returns the shortest path or all paths of influence ("Fractillion Trace") between them.
      * GET /api/timeline/dna: Fetch the data structured chronologically for the "DNA Helix" view.
________________
Phase 2: Rebuilding Layer 1 - The Orb of Historical Wisdom
With a stable foundation and a data backend, rebuild the core visualization correctly and performantly.
1. The Authoritative Visualization Component:
   * Action: Refactor Globe.tsx to be a pure, performant Three.js scene manager.
   * Task:
      * Its sole responsibility is rendering. All application state (filters, selections) should be piped in as props from Zustand.
      * On mount, it should call the /api/graph/full endpoint to fetch the initial data.
2. Implement High-Performance Rendering:
   * Action: Re-architect the rendering of philosopher nodes and connections for scale.
   * Task 1 (Instanced Rendering): Do not create a THREE.Mesh per philosopher. Use a single THREE.InstancedMesh to render all philosopher spheres in a single draw call. Individual properties like position and scale will be managed via instance matrices.
   * Task 2 (Efficient Materials): Do not create a ShaderMaterial per node. Create one shared ShaderMaterial for all instanced spheres. Pass in color information (based on spiralDynamicsStage or domain) as a per-instance attribute.
   * Task 3 (GPU-Based Connections): The particle system for the "Fractillion Trace" connections must not be animated on the CPU. Move this entire simulation to the GPU. Use a custom vertex shader to calculate particle positions along connection splines based on a time uniform.
3. Implement the Core Vision:
   * Action: Build the visualization to match the design specification.
   * Task:
      * Nested Spheres: Implement the core structural metaphor of nested, chronological spheres.
      * Visual Fidelity: Implement Spiral Dynamics color-coding, transparency, wireframe aesthetics, and the five radial "Pillar" wedges for domains.
      * Fractillion Trace & 3D Graph Layout: This is a major sub-task. Implement or integrate a 3D force-directed graph layout algorithm to calculate the node positions for the "Fractillion Trace" view. The data from Neo4j provides the connections; this algorithm provides the layout.
      * Interactivity: Implement the "Switch Points" visualization and the transformation from the Orb view to the "DNA Helix" timeline view.
________________
Phase 3: Architecting Layer 2 & Layer 3
Plan the architecture for the dynamic and personalized layers of the application.
1. Layer 2 - The Personal Orb:
   * Action: Design the backend and frontend systems required for user personalization.
   * Task (Architecture Plan):
      * Authentication: Plan the integration of a solution like NextAuth.js.
      * Database Schema: Design the schema extensions (either in Neo4j or a complementary PostgreSQL database for relational user data) needed to store user profiles, quiz results, endorsements, and the resulting "philosophical profile."
      * API Routes: Define the new authenticated API endpoints required: POST /api/user/endorse, GET /api/user/profile, etc.
      * Implication Engine: Plan the logic for the "Implication Engine" as a server-side process that analyzes a user's endorsements and calculates logical consequences based on the graph data.
2. Layer 3 - The Resonance Chamber (R&D Spike):
   * Action: Frame this high-risk, high-reward feature as a formal Research & Development spike.
   * Task (R&D Plan):
      * Data-to-Art Mapping: The primary challenge is defining the translation layer. Your plan should task a developer with prototyping how a user's high-dimensional philosophical profile (a vector of beliefs and endorsements) can be mapped to the parameters of a particle simulation (e.g., velocity, color, turbulence, lifespan, force vectors).
      * Technology: Specify that this prototype must be built using GPU Compute Shaders (GPGPU) for simulating the behavior of millions of particles efficiently, as a traditional vertex shader approach will not be sufficient for the envisioned complexity.
________________
Phase 4: UI/UX Decoupling and Refinement
1. Component Refactoring:
   * Action: Refactor all UI components (Sidebar.tsx, InfoPanel.tsx, PhilosopherPanel.tsx, etc.).
   * Task: Ensure they are "dumb" components. They should contain no application logic. All state and actions should be passed in from their parent components or, preferably, connected directly to the Zustand store.
   * Goal: A fully decoupled architecture where the UI can be changed or developed independently of the 3D visualization logic.
2. CSS and Styling:
   * Action: Resolve all styling conflicts.
   * Task: Conduct a full review of the CSS, fix the inconsistent application of the glass-dark class, and establish a clear, maintainable styling system (e.g., using CSS Modules or a CSS-in-JS library).
By following this comprehensive, multi-phase plan, you will systematically eliminate every critical flaw in the 'Philosophical Nexus' project. You will build a robust, scalable, and performant foundation that is finally capable of realizing the project's magnificent and groundbreaking vision.